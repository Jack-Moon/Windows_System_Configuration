# Function to safely disable Windows services
function Disable-WindowsService {
    param(
        [string]$ServiceName,
        [string]$Description = ""
    )
    
    Write-DetailedLog -Message "Processing service: $ServiceName" -Level "OPERATION" -Component "SERVICES"
    
    try {
        $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if ($serviceObj) {
            Write-DetailedLog -Message "Service found: $ServiceName - Status: $($serviceObj.Status), StartType: $($serviceObj.StartType)" -Level "INFO" -Component "SERVICES"
            Write-Host "Processing service: $ServiceName" -ForegroundColor Cyan
            
            # Display current status
            Write-Host "  Current status: $($serviceObj.Status)" -ForegroundColor Gray
            Write-Host "  Startup type: $($serviceObj.StartType)" -ForegroundColor Gray
            if ($Description) {
                Write-DetailedLog -Message "Service description: $Description" -Level "INFO" -Component "SERVICES"
                Write-Host "  Purpose: $Description" -ForegroundColor Gray
            }
            
            # Backup current service state
            Write-DetailedLog -Message "Backing up service state: $ServiceName - Status: $($serviceObj.Status), StartType: $($serviceObj.StartType)" -Level "BACKUP" -Component "SERVICES"
            
            # Stop the service if it's running
            if ($serviceObj.Status -eq 'Running') {
                Write-DetailedLog -Message "Stopping running service: $ServiceName" -Level "OPERATION" -Component "SERVICES"
                Write-Host "  Stopping service..." -ForegroundColor Yellow
                Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 1  # Brief pause to allow service to stop
                
                # Verify service stopped
                $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
                if ($serviceObj.Status -eq 'Stopped') {
                    Write-DetailedLog -Message "Service stopped successfully: $ServiceName" -Level "SUCCESS" -Component "SERVICES"
                    Write-Host "  ✓ Service stopped successfully" -ForegroundColor Green
                } else {
                    Write-DetailedLog -Message "Service may still be running: $ServiceName - Status: $($serviceObj.Status)" -Level "WARNING" -Component "SERVICES"
                    Write-Host "  ⚠ Service may still be running" -ForegroundColor Yellow
                }
            }
            
            # Disable the service
            Write-DetailedLog -Message "Setting service startup type to Disabled: $ServiceName" -Level "OPERATION" -Component "SERVICES"
            Write-Host "  Setting startup type to Disabled..." -ForegroundColor Yellow
            Set-Service -Name $ServiceName -StartupType Disabled -ErrorAction SilentlyContinue
            
            # Verify the change
            $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
            if ($serviceObj.StartType -eq 'Disabled') {
                Write-DetailedLog -Message "Service disabled successfully: $ServiceName" -Level "SUCCESS" -Component "SERVICES"
                Write-Host "  ✓ Service disabled successfully: $ServiceName" -ForegroundColor Green
            } else {
                Write-DetailedLog -Message "Service may not be properly disabled: $ServiceName - StartType: $($serviceObj.StartType)" -Level "WARNING" -Component "SERVICES"
                Write-Host "  ⚠ Service may not be properly disabled: $ServiceName" -ForegroundColor Yellow
            }
        } else {
            Write-DetailedLog -Message "Service not found: $ServiceName" -Level "WARNING" -Component "SERVICES"
            Write-Host "⚠ Service not found: $ServiceName" -ForegroundColor Yellow
        }
    } catch {
        Write-DetailedLog -Message "Error processing service $ServiceName: $($_.Exception.Message)" -Level "ERROR" -Component "SERVICES"
        Write-Host "✗ Error processing service $ServiceName : $($_.Exception.Message)" -ForegroundColor Red
    }
}# ===================================================================
# Windows System Configuration Script
# Purpose: Automated setup and customization for corporate environment
# Usage: .\script.ps1 -Mode home|work
# ===================================================================

param(
    [Parameter(Mandatory=$true)]
    [ValidateSet("home", "work")]
    [string]$Mode,
    
    [Parameter(Mandatory=$false)]
    [switch]$BackupSoftware,
    
    [Parameter(Mandatory=$false)]
    [switch]$BackupAllInstalledSoftware,
    
    [Parameter(Mandatory=$false)]
    [switch]$Restore,
    
    [Parameter(Mandatory=$false)]
    [switch]$Rollback,
    
    [Parameter(Mandatory=$false)]
    [string]$BackupBasePath = "$env:USERPROFILE\Documents\WindowsConfigBackups"
)

# ===================================================================
# INITIALIZATION & VALIDATION
# ===================================================================

# 1. Check for Administrator Privileges
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Warning "Administrator privileges are required for this script."
    Write-Warning "Please re-launch the script from an elevated PowerShell session."
    exit
}

# 2. Set Execution Policy
# Set a safer execution policy for the current user scope. This is less permissive than 'Unrestricted'.
try {
    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
    Write-Host "Execution policy set to 'RemoteSigned' for the current user." -ForegroundColor Green
} catch {
    Write-Warning "Failed to set execution policy. Script may not run without '-ExecutionPolicy Bypass'."
}

# ===================================================================
# LOGGING SYSTEM
# ===================================================================

# Initialize logging
$ScriptName = "WindowsConfigScript"
$LogTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
$LogFileName = "$ScriptName" + "_log_" + "$LogTimestamp.log"
$LogPath = "$BackupBasePath\$LogFileName"

# Ensure log directory exists
if (!(Test-Path $BackupBasePath)) {
    New-Item -Path $BackupBasePath -ItemType Directory -Force | Out-Null
}

# Global logging functions
function Write-DetailedLog {
    param(
        [string]$Message,
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS", "OPERATION", "BACKUP", "RESTORE")]
        [string]$Level = "INFO",
        [string]$Component = "MAIN",
        [switch]$NoDisplay
    )
    
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogEntry = "[$Timestamp] [$Level] [$Component] $Message"
    
    # Write to log file
    try {
        Add-Content -Path $LogPath -Value $LogEntry -ErrorAction SilentlyContinue
    } catch {
        # Fallback if log file is locked
        Write-Host "Warning: Could not write to log file" -ForegroundColor Yellow
    }
    
    # Display on screen with colors if not suppressed
    if (-not $NoDisplay) {
        switch ($Level) {
            "SUCCESS" { Write-Host $Message -ForegroundColor Green }
            "WARNING" { Write-Host $Message -ForegroundColor Yellow }
            "ERROR" { Write-Host $Message -ForegroundColor Red }
            "OPERATION" { Write-Host $Message -ForegroundColor Cyan }
            "BACKUP" { Write-Host $Message -ForegroundColor Magenta }
            "RESTORE" { Write-Host $Message -ForegroundColor Blue }
            default { Write-Host $Message -ForegroundColor White }
        }
    }
}

function Start-OperationLog {
    param(
        [string]$OperationName,
        [hashtable]$Parameters = @{}
    )
    
    Write-DetailedLog -Message "=== STARTING OPERATION: $OperationName ===" -Level "OPERATION"
    Write-DetailedLog -Message "Operation Parameters: $($Parameters | ConvertTo-Json -Compress)" -Level "INFO"
    Write-DetailedLog -Message "User: $env:USERNAME" -Level "INFO"
    Write-DetailedLog -Message "Computer: $env:COMPUTERNAME" -Level "INFO"
    Write-DetailedLog -Message "PowerShell Version: $($PSVersionTable.PSVersion)" -Level "INFO"
    Write-DetailedLog -Message "Execution Policy: $(Get-ExecutionPolicy)" -Level "INFO"
    Write-DetailedLog -Message "Running as Administrator: $([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)" -Level "INFO"
}

function End-OperationLog {
    param(
        [string]$OperationName,
        [bool]$Success = $true
    )
    
    $status = if ($Success) { "COMPLETED SUCCESSFULLY" } else { "FAILED" }
    $level = if ($Success) { "SUCCESS" } else { "ERROR" }
    Write-DetailedLog -Message "=== OPERATION $OperationName $status ===" -Level $level
}

# ===================================================================
# BACKUP CONFIGURATION CONSTANTS
# ===================================================================

# Create standardized backup path structure
$BackupTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
$StandardBackupPath = "$BackupBasePath\$BackupTimestamp"

function New-SystemBackup {
    param([string]$BackupReason = "Pre-Script-Execution")
    
    Write-DetailedLog -Message "Creating system backup before making changes..." -Level "BACKUP"
    
    $systemBackupPath = "$BackupBasePath\SystemBackup_$LogTimestamp"
    New-Item -Path $systemBackupPath -ItemType Directory -Force | Out-Null
    
    try {
        # Backup critical registry keys
        Write-DetailedLog -Message "Backing up critical registry keys..." -Level "BACKUP"
        
        $criticalKeys = @{
            "HKCU_Explorer" = "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer"
            "HKCU_Policies" = "HKEY_CURRENT_USER\Software\Policies"
            "HKLM_Policies" = "HKEY_LOCAL_MACHINE\SOFTWARE\Policies"
            "HKLM_Windows" = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion"
            "Services" = "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services"
        }
        
        foreach ($key in $criticalKeys.GetEnumerator()) {
            try {
                $backupFile = "$systemBackupPath\$($key.Key).reg"
                reg export "$($key.Value)" "$backupFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-DetailedLog -Message "Backed up registry key: $($key.Key)" -Level "BACKUP"
                } else {
                    Write-DetailedLog -Message "Failed to backup registry key: $($key.Key)" -Level "WARNING"
                }
            } catch {
                Write-DetailedLog -Message "Error backing up $($key.Key): $($_.Exception.Message)" -Level "ERROR"
            }
        }
        
        # Backup current services configuration
        Write-DetailedLog -Message "Backing up services configuration..." -Level "BACKUP"
        try {
            Get-Service | Select-Object Name, Status, StartType | 
                Export-Csv "$systemBackupPath\ServicesBackup.csv" -NoTypeInformation
            Write-DetailedLog -Message "Services configuration backed up successfully" -Level "BACKUP"
        } catch {
            Write-DetailedLog -Message "Failed to backup services: $($_.Exception.Message)" -Level "ERROR"
        }
        
        # Backup current Windows features
        Write-DetailedLog -Message "Backing up Windows features..." -Level "BACKUP"
        try {
            Get-WindowsOptionalFeature -Online | 
                Export-Csv "$systemBackupPath\WindowsFeaturesBackup.csv" -NoTypeInformation
            Write-DetailedLog -Message "Windows features backed up successfully" -Level "BACKUP"
        } catch {
            Write-DetailedLog -Message "Failed to backup Windows features: $($_.Exception.Message)" -Level "ERROR"
        }
        
        # Create rollback script
        $rollbackScript = @"
# System Rollback Script
# Generated: $(Get-Date)
# Backup Location: $systemBackupPath

Write-Host "System Rollback Script" -ForegroundColor Red
Write-Host "======================" -ForegroundColor Red
Write-Host "This will restore system settings to state before script execution"
Write-Host "Backup created: $(Get-Date)"

# Restore registry keys
Write-Host "`nRestoring registry keys..." -ForegroundColor Yellow
Get-ChildItem "$systemBackupPath\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Restore services
Write-Host "`nRestoring services configuration..." -ForegroundColor Yellow
try {
    `$servicesBackup = Import-Csv "$systemBackupPath\ServicesBackup.csv"
    foreach (`$service in `$servicesBackup) {
        try {
            `$currentService = Get-Service -Name `$service.Name -ErrorAction SilentlyContinue
            if (`$currentService) {
                if (`$service.StartType -ne `$currentService.StartType) {
                    Set-Service -Name `$service.Name -StartupType `$service.StartType
                    Write-Host "✓ Restored service startup: `$(`$service.Name) -> `$(`$service.StartType)" -ForegroundColor Green
                }
                
                if (`$service.Status -eq "Running" -and `$currentService.Status -eq "Stopped") {
                    Start-Service -Name `$service.Name -ErrorAction SilentlyContinue
                    Write-Host "✓ Started service: `$(`$service.Name)" -ForegroundColor Green
                }
            }
        } catch {
            Write-Host "⚠ Could not restore service: `$(`$service.Name)" -ForegroundColor Yellow
        }
    }
} catch {
    Write-Host "✗ Failed to restore services configuration" -ForegroundColor Red
}

Write-Host "`n✅ System rollback completed" -ForegroundColor Green
Write-Host "Please restart the computer to ensure all changes take effect" -ForegroundColor Yellow
"@
        
        $rollbackScript | Out-File "$systemBackupPath\ROLLBACK_SYSTEM.ps1" -Encoding UTF8
        
        # Create backup manifest
        $backupManifest = @{
            BackupDate = Get-Date
            BackupReason = $BackupReason
            BackupPath = $systemBackupPath
            LogFile = $LogPath
            User = $env:USERNAME
            Computer = $env:COMPUTERNAME
            ScriptVersion = "2.0"
        }
        
        $backupManifest | ConvertTo-Json -Depth 3 | Out-File "$systemBackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-DetailedLog -Message "System backup completed successfully at: $systemBackupPath" -Level "SUCCESS"
        return $systemBackupPath
        
    } catch {
        Write-DetailedLog -Message "System backup failed: $($_.Exception.Message)" -Level "ERROR"
        return $null
    }
}

function Start-SystemRollback {
    Write-DetailedLog -Message "Starting system rollback process..." -Level "RESTORE"
    
    if (!(Test-Path $BackupBasePath)) {
        Write-DetailedLog -Message "No backup directory found: $BackupBasePath" -Level "ERROR"
        return $false
    }
    
    # Find available system backups
    $systemBackups = Get-ChildItem $BackupBasePath -Directory | 
        Where-Object { $_.Name -like "SystemBackup_*" } |
        Sort-Object CreationTime -Descending
    
    if ($systemBackups.Count -eq 0) {
        Write-DetailedLog -Message "No system backups found for rollback" -Level "ERROR"
        return $false
    }
    
    Write-Host "`n🔄 SYSTEM ROLLBACK" -ForegroundColor Red
    Write-Host "Available system backups:" -ForegroundColor Yellow
    
    for ($i = 0; $i -lt $systemBackups.Count; $i++) {
        $backup = $systemBackups[$i]
        $manifestPath = Join-Path $backup.FullName "BACKUP_MANIFEST.json"
        
        if (Test-Path $manifestPath) {
            try {
                $manifest = Get-Content $manifestPath | ConvertFrom-Json
                Write-Host "$($i + 1). $($backup.Name)" -ForegroundColor Cyan
                Write-Host "   Date: $($manifest.BackupDate)" -ForegroundColor Gray
                Write-Host "   Reason: $($manifest.BackupReason)" -ForegroundColor Gray
            } catch {
                Write-Host "$($i + 1). $($backup.Name) (corrupted manifest)" -ForegroundColor Yellow
            }
        } else {
            Write-Host "$($i + 1). $($backup.Name) (no manifest)" -ForegroundColor Yellow
        }
    }
    
    Write-Host "`nSelect backup to rollback to (1-$($systemBackups.Count)) or 'q' to quit: " -NoNewline
    $selection = Read-Host
    
    if ($selection -eq 'q' -or $selection -eq 'Q') {
        Write-DetailedLog -Message "Rollback cancelled by user" -Level "INFO"
        return $false
    }
    
    if ($selection -match '^\d+

# ===================================================================
# POWER MANAGEMENT
# ===================================================================

# Set active power plan to High Performance
Write-Host "Configuring power management..." -ForegroundColor Green
powercfg.exe -SETACTIVE 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c

# Disable Fast Startup (improves boot reliability)
REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f

# ===================================================================
# REMOTE DESKTOP CONFIGURATION
# ===================================================================

Write-Host "Enabling Remote Desktop..." -ForegroundColor Green

# Enable Remote Desktop connections (Registry method)
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

# Enable Remote Desktop connections (PowerShell method)
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0

# Enable Remote Desktop firewall rules
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

# Alternative firewall configuration (commented out)
# netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
# netsh advfirewall firewall add rule name="allow RemoteDesktop" dir=in protocol=TCP localport=3389 action=allow

# ===================================================================
# NETWORK CONFIGURATION
# ===================================================================

# Enable ICMP ping responses for local subnet
Write-Host "Configuring network settings..." -ForegroundColor Green
New-NetFirewallRule -DisplayName "!!! ICMP PING" -Direction Inbound -Protocol ICMPv4 -RemoteAddress LocalSubnet -Action Allow

# Disable IPv6 on all network adapters (commented out)
# Disable-NetAdapterBinding -Name * -ComponentID ms_tcpip6

# ===================================================================
# USER INTERFACE CUSTOMIZATIONS
# ===================================================================

Write-Host "Customizing user interface..." -ForegroundColor Green

# Enable classic context menu in Windows 11
reg add "HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" /f /ve

# Disable Windows Quiet Hours/Focus Assist
reg add "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\QuietHours" /v Enable /t REG_DWORD /d 0 /f

# ===================================================================
# TASKBAR CUSTOMIZATION
# ===================================================================

Write-Host "Customizing taskbar..." -ForegroundColor Green

# Function to unpin applications from taskbar
function Unpin-FromTaskbar {
    param([string]$AppName)
    
    $app = (New-Object -Com Shell.Application).NameSpace('shell:::{4234d49b-0245-4df3-b780-3893943456e1}').Items() | Where-Object {$_.Name -eq $AppName}
    if ($app) {
        $unpinVerb = $app.Verbs() | Where-Object {$_.Name.replace('&','') -match 'Unpin from taskbar'}
        if ($unpinVerb) {
            $unpinVerb.DoIt()
            Write-Host "Unpinned $AppName from taskbar" -ForegroundColor Yellow
        }
    }
}

# Unpin default applications from taskbar
Unpin-FromTaskbar "Microsoft Edge"
Unpin-FromTaskbar "Microsoft Store"
Unpin-FromTaskbar "Mail"

# Hide search box from taskbar
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Search" /v SearchboxTaskbarMode /t REG_DWORD /d 0 /f

# Hide Task View button from taskbar
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v ShowTaskViewButton /t REG_DWORD /d 0 /f

# Hide Cortana button from taskbar
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v ShowCortanaButton /t REG_DWORD /d 0 /f

# Hide Teams Chat icon from taskbar (Windows 11)
REG ADD "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /f /v TaskbarMn /t REG_DWORD /d 0

# Disable multitasking view
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MultiTaskingView\AllUpView" /v Enabled /t REG_DWORD /d 0 /f

# Disable auto-tray for system icons
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer" /v EnableAutoTray /t REG_DWORD /d 0 /f

# ===================================================================
# FILE EXPLORER CONFIGURATION
# ===================================================================

Write-Host "Configuring File Explorer..." -ForegroundColor Green

# Set File Explorer to open to "This PC" instead of Quick Access
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v LaunchTo /t REG_DWORD /d 1 /f

# ===================================================================
# CORTANA AND SEARCH CONFIGURATION
# ===================================================================

Write-Host "Disabling Cortana..." -ForegroundColor Green

# Disable Cortana
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search" /v AllowCortana /t REG_DWORD /d 0 /f

# Disable Cortana above lock screen
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search" /v AllowCortanaAboveLock /t REG_DWORD /d 0 /f

# Disable search location usage
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search" /v AllowSearchToUseLocation /t REG_DWORD /d 0 /f

# Disable Windows Feeds (News and Interests)
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Feeds" /v EnableFeeds /t REG_DWORD /d 0 /f

# ===================================================================
# USER ACCOUNT CONFIGURATION
# ===================================================================

Write-Host "Configuring user accounts..." -ForegroundColor Green

# Hide specific user accounts from login screen
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v "it dept" /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v "jack" /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v "jacek_brychcy_p" /t REG_DWORD /d 0 /f

# Set IT DEPT user password to never expire
try {
    Set-LocalUser -Name "IT DEPT" -PasswordNeverExpires $true
    Write-Host "IT DEPT password set to never expire" -ForegroundColor Yellow
} catch {
    Write-Host "Could not configure IT DEPT user - user may not exist" -ForegroundColor Red
}

# ===================================================================
# OFFICE CONFIGURATION
# ===================================================================

Write-Host "Configuring Office applications..." -ForegroundColor Green

# Disable Outlook connection check message
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\16.0\Outlook\Options\General" /v "EnableImprovedCaptivePortalExperience" /t REG_DWORD /d 0 /f

# ===================================================================
# SYSTEM OPTIMIZATION
# ===================================================================

Write-Host "Optimizing system performance..." -ForegroundColor Green

# Disable indexing on all volumes
Get-WmiObject -Class win32_volume | Set-WmiInstance -Arguments @{IndexingEnabled=$false}

# Remove Microsoft Teams (if installed)
Write-Host "Removing Microsoft Teams..." -ForegroundColor Yellow
Get-AppxPackage *Teams* | Remove-AppxPackage -AllUsers -ErrorAction SilentlyContinue
Get-AppxProvisionedPackage -online | Where-Object {$_.PackageName -like "*Teams*"} | Remove-AppxProvisionedPackage -online -ErrorAction SilentlyContinue

# Uninstall Windows Web Experience Pack (Windows 11)
try {
    winget uninstall "windows web experience pack" --force --accept-source-agreements
} catch {
    Write-Host "Windows Web Experience Pack not found or already removed" -ForegroundColor Yellow
}

# ===================================================================
# SOFTWARE INSTALLATION AND CONFIGURATION
# ===================================================================

Write-Host "Installing PowerShell modules and software..." -ForegroundColor Green

# Install essential PowerShell modules
try {
    Install-Module -Name PSReadLine, PSWindowsUpdate, Carbon, ImportExcel -Force -AllowClobber -Scope AllUsers
    Write-Host "PowerShell modules installed successfully" -ForegroundColor Green
} catch {
    Write-Host "Error installing PowerShell modules: $($_.Exception.Message)" -ForegroundColor Red
}

# Ensure Winget is available and updated
try {
    $wingetVersion = winget --version
    Write-Host "Winget is available (version: $wingetVersion)" -ForegroundColor Green
} catch {
    Write-Host "Winget not available, will use Chocolatey as fallback" -ForegroundColor Yellow
}

# Check if Chocolatey is installed, if not install it
if (!(Get-Command choco.exe -ErrorAction SilentlyContinue)) {
    Write-Host "Installing Chocolatey package manager..." -ForegroundColor Yellow
    try {
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
        $env:PATH = [Environment]::GetEnvironmentVariable("PATH","Machine") + ";" + [Environment]::GetEnvironmentVariable("PATH","User")
        Write-Host "Chocolatey installed successfully" -ForegroundColor Green
    } catch {
        Write-Host "Failed to install Chocolatey: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to install software with Winget first, fallback to Chocolatey
function Install-Software {
    param(
        [string]$SoftwareName,
        [string]$WingetID = "",
        [string]$ChocoPackage = "",
        [string]$ChocoParams = "",
        [bool]$Silent = $false
    )
    
    $installed = $false
    
    # Try Winget first if ID is provided
    if ($WingetID -ne "" -and (Get-Command winget -ErrorAction SilentlyContinue)) {
        try {
            Write-Host "Attempting to install $SoftwareName via Winget..." -ForegroundColor Cyan
            winget install --id=$WingetID --accept-source-agreements --accept-package-agreements --silent
            if ($LASTEXITCODE -eq 0) {
                Write-Host "$SoftwareName installed successfully via Winget" -ForegroundColor Green
                $installed = $true
            } else {
                Write-Host "Winget installation failed for $SoftwareName (Exit code: $LASTEXITCODE)" -ForegroundColor Yellow
            }
        } catch {
            Write-Host "Winget installation failed for $SoftwareName : $($_.Exception.Message)" -ForegroundColor Yellow
        }
    }
    
    # Fallback to Chocolatey if Winget failed or not available
    if (-not $installed -and $ChocoPackage -ne "") {
        try {
            Write-Host "Installing $SoftwareName via Chocolatey..." -ForegroundColor Cyan
            if ($ChocoParams -ne "") {
                choco install $ChocoPackage -y $ChocoParams
            } else {
                choco install $ChocoPackage -y
            }
            if ($LASTEXITCODE -eq 0) {
                Write-Host "$SoftwareName installed successfully via Chocolatey" -ForegroundColor Green
                $installed = $true
            } else {
                Write-Host "Chocolatey installation failed for $SoftwareName (Exit code: $LASTEXITCODE)" -ForegroundColor Red
            }
        } catch {
            Write-Host "Chocolatey installation failed for $SoftwareName : $($_.Exception.Message)" -ForegroundColor Red
        }
    }
    
    if (-not $installed) {
        Write-Host "Failed to install $SoftwareName via both Winget and Chocolatey" -ForegroundColor Red
    }
    
    return $installed
}

# Function to prompt user for software installation
function Ask-InstallSoftware {
    param(
        [string]$SoftwareName,
        [string]$WingetID = "",
        [string]$ChocoPackage = "",
        [string]$Description = "",
        [string]$ChocoParams = ""
    )
    
    $choice = Read-Host "Do you want to install $SoftwareName ($Description)? (y/n)"
    if ($choice -eq 'y' -or $choice -eq 'Y' -or $choice -eq 'yes') {
        Install-Software -SoftwareName $SoftwareName -WingetID $WingetID -ChocoPackage $ChocoPackage -ChocoParams $ChocoParams
    } else {
        Write-Host "Skipping $SoftwareName installation" -ForegroundColor Yellow
    }
}

# Software installation based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- HOME MODE SOFTWARE SELECTION ---" -ForegroundColor Cyan
    Write-Host "Select software to install. Each category will be presented separately." -ForegroundColor Yellow
    
    # ===================================================================
    # BASIC APPLICATIONS
    # ===================================================================
    Write-Host "`n=== BASIC APPLICATIONS ===" -ForegroundColor Magenta
    
    # Bitwarden
    Ask-InstallSoftware -SoftwareName "Bitwarden" -WingetID "Bitwarden.Bitwarden" -ChocoPackage "bitwarden" -Description "Password manager"
    
    # Office 365 Enterprise
    Ask-InstallSoftware -SoftwareName "Office 365 Enterprise" -WingetID "Microsoft.Office" -ChocoPackage "office365business" -Description "Microsoft Office suite"
    
    # Visual Studio Code
    Ask-InstallSoftware -SoftwareName "Visual Studio Code" -WingetID "Microsoft.VisualStudioCode" -ChocoPackage "vscode" -Description "Code editor and IDE" -ChocoParams "--params '/NoDesktopIcon /NoQuicklaunchIcon'"
    
    # ===================================================================
    # WINDOWS ADMINISTRATION TOOLS
    # ===================================================================
    Write-Host "`n=== WINDOWS ADMINISTRATION TOOLS ===" -ForegroundColor Magenta
    
    # Windows Terminal
    Ask-InstallSoftware -SoftwareName "Windows Terminal" -WingetID "Microsoft.WindowsTerminal" -ChocoPackage "microsoft-windows-terminal" -Description "Modern terminal application"
    
    # PowerToys
    Ask-InstallSoftware -SoftwareName "PowerToys" -WingetID "Microsoft.PowerToys" -ChocoPackage "powertoys" -Description "Windows system utilities"
    
    # Sysinternals Suite
    Ask-InstallSoftware -SoftwareName "Sysinternals Suite" -WingetID "Microsoft.Sysinternals" -ChocoPackage "sysinternals" -Description "Windows diagnostic tools"
    
    # Process Monitor
    Ask-InstallSoftware -SoftwareName "Process Monitor" -WingetID "Microsoft.Sysinternals.ProcessMonitor" -ChocoPackage "procmon" -Description "Real-time file system and process monitoring"
    
    # Process Explorer
    Ask-InstallSoftware -SoftwareName "Process Explorer" -WingetID "Microsoft.Sysinternals.ProcessExplorer" -ChocoPackage "procexp" -Description "Advanced Task Manager replacement"
    
    # CMTrace
    Ask-InstallSoftware -SoftwareName "CMTrace" -WingetID "" -ChocoPackage "cmtrace" -Description "Microsoft log viewer tool"
    
    # Dell Command Update
    Ask-InstallSoftware -SoftwareName "Dell Command Update" -WingetID "Dell.CommandUpdate" -ChocoPackage "DellCommandUpdate" -Description "Dell driver and BIOS updates"
    
    # ===================================================================
    # NETWORK & SECURITY TOOLS
    # ===================================================================
    Write-Host "`n=== NETWORK & SECURITY TOOLS ===" -ForegroundColor Magenta
    
    # Wireshark
    Ask-InstallSoftware -SoftwareName "Wireshark" -WingetID "WiresharkFoundation.Wireshark" -ChocoPackage "wireshark" -Description "Network protocol analyzer"
    
    # PuTTY
    Ask-InstallSoftware -SoftwareName "PuTTY" -WingetID "PuTTY.PuTTY" -ChocoPackage "putty" -Description "SSH and telnet client"
    
    # WinSCP
    Ask-InstallSoftware -SoftwareName "WinSCP" -WingetID "WinSCP.WinSCP" -ChocoPackage "winscp" -Description "SFTP and SCP client"
    
    # OpenVPN Connect
    Ask-InstallSoftware -SoftwareName "OpenVPN Connect" -WingetID "OpenVPNTechnologies.OpenVPNConnect" -ChocoPackage "openvpn-connect" -Description "VPN client"
    
    # Nmap
    Ask-InstallSoftware -SoftwareName "Nmap" -WingetID "Insecure.Nmap" -ChocoPackage "nmap" -Description "Network discovery and security auditing"
    
    # ===================================================================
    # VERSION CONTROL & GIT
    # ===================================================================
    Write-Host "`n=== VERSION CONTROL & GIT ===" -ForegroundColor Magenta
    
    # Git for Windows
    Ask-InstallSoftware -SoftwareName "Git for Windows" -WingetID "Git.Git" -ChocoPackage "git" -Description "Distributed version control system"
    
    # GitHub Desktop
    Ask-InstallSoftware -SoftwareName "GitHub Desktop" -WingetID "GitHub.GitHubDesktop" -ChocoPackage "github-desktop" -Description "GUI for GitHub"
    
    # Sourcetree
    Ask-InstallSoftware -SoftwareName "Sourcetree" -WingetID "Atlassian.Sourcetree" -ChocoPackage "sourcetree" -Description "Git GUI client"
    
    # ===================================================================
    # DEVELOPMENT TOOLS
    # ===================================================================
    Write-Host "`n=== DEVELOPMENT TOOLS ===" -ForegroundColor Magenta
    
    # Notepad++
    Ask-InstallSoftware -SoftwareName "Notepad++" -WingetID "Notepad++.Notepad++" -ChocoPackage "notepadplusplus" -Description "Advanced text editor"
    
    # JetBrains Toolbox
    Ask-InstallSoftware -SoftwareName "JetBrains Toolbox" -WingetID "JetBrains.Toolbox" -ChocoPackage "jetbrainstoolbox" -Description "JetBrains IDE manager"
    
    # IntelliJ IDEA Community
    Ask-InstallSoftware -SoftwareName "IntelliJ IDEA Community" -WingetID "JetBrains.IntelliJIDEA.Community" -ChocoPackage "intellijidea-community" -Description "Java IDE"
    
    # PyCharm Community
    Ask-InstallSoftware -SoftwareName "PyCharm Community" -WingetID "JetBrains.PyCharm.Community" -ChocoPackage "pycharm-community" -Description "Python IDE"
    
    # ===================================================================
    # PYTHON ECOSYSTEM
    # ===================================================================
    Write-Host "`n=== PYTHON ECOSYSTEM ===" -ForegroundColor Magenta
    
    # Python
    Ask-InstallSoftware -SoftwareName "Python" -WingetID "Python.Python.3.12" -ChocoPackage "python" -Description "Python programming language"
    
    # Miniconda
    Ask-InstallSoftware -SoftwareName "Miniconda" -WingetID "Anaconda.Miniconda3" -ChocoPackage "miniconda3" -Description "Minimal conda installer"
    
    # Anaconda
    Ask-InstallSoftware -SoftwareName "Anaconda" -WingetID "Anaconda.Anaconda3" -ChocoPackage "anaconda3" -Description "Data science platform"
    
    # ===================================================================
    # AI/LLM DEVELOPMENT
    # ===================================================================
    Write-Host "`n=== AI/LLM DEVELOPMENT ===" -ForegroundColor Magenta
    
    # Ollama
    Ask-InstallSoftware -SoftwareName "Ollama" -WingetID "Ollama.Ollama" -ChocoPackage "ollama" -Description "Run large language models locally"
    
    # LM Studio
    Ask-InstallSoftware -SoftwareName "LM Studio" -WingetID "LMStudio.LMStudio" -ChocoPackage "lmstudio" -Description "GUI for local LLMs"
    
    # CUDA Toolkit (for NVIDIA GPUs)
    Ask-InstallSoftware -SoftwareName "CUDA Toolkit" -WingetID "Nvidia.CUDA" -ChocoPackage "cuda" -Description "NVIDIA GPU computing toolkit"
    
    # ===================================================================
    # CONTAINER & CLOUD TOOLS
    # ===================================================================
    Write-Host "`n=== CONTAINER & CLOUD TOOLS ===" -ForegroundColor Magenta
    
    # Docker Desktop
    Ask-InstallSoftware -SoftwareName "Docker Desktop" -WingetID "Docker.DockerDesktop" -ChocoPackage "docker-desktop" -Description "Containerization platform"
    
    # Kubernetes CLI
    Ask-InstallSoftware -SoftwareName "Kubectl" -WingetID "Kubernetes.kubectl" -ChocoPackage "kubernetes-cli" -Description "Kubernetes command-line tool"
    
    # Lens
    Ask-InstallSoftware -SoftwareName "Lens" -WingetID "MiranovaTeam.Lens" -ChocoPackage "lens" -Description "Kubernetes IDE"
    
    # Azure CLI
    Ask-InstallSoftware -SoftwareName "Azure CLI" -WingetID "Microsoft.AzureCLI" -ChocoPackage "azure-cli" -Description "Azure command-line interface"
    
    # AWS CLI
    Ask-InstallSoftware -SoftwareName "AWS CLI" -WingetID "Amazon.AWSCLI" -ChocoPackage "awscli" -Description "Amazon Web Services CLI"
    
    # Google Cloud SDK
    Ask-InstallSoftware -SoftwareName "Google Cloud SDK" -WingetID "Google.CloudSDK" -ChocoPackage "gcloudsdk" -Description "Google Cloud command-line tools"
    
    # Terraform
    Ask-InstallSoftware -SoftwareName "Terraform" -WingetID "Hashicorp.Terraform" -ChocoPackage "terraform" -Description "Infrastructure as Code tool"
    
    # ===================================================================
    # COMMUNICATION & MEDIA
    # ===================================================================
    Write-Host "`n=== COMMUNICATION & MEDIA ===" -ForegroundColor Magenta
    
    # Facebook Messenger
    Ask-InstallSoftware -SoftwareName "Facebook Messenger" -WingetID "Facebook.Messenger" -ChocoPackage "messenger" -Description "Facebook messaging app"
    
    # WhatsApp Desktop
    Ask-InstallSoftware -SoftwareName "WhatsApp Desktop" -WingetID "WhatsApp.WhatsApp" -ChocoPackage "whatsapp" -Description "WhatsApp messaging app"
    
    # PotPlayer
    Ask-InstallSoftware -SoftwareName "PotPlayer" -WingetID "Daum.PotPlayer" -ChocoPackage "potplayer" -Description "Media player"
    
    # VLC Media Player
    Ask-InstallSoftware -SoftwareName "VLC Media Player" -WingetID "VideoLAN.VLC" -ChocoPackage "vlc" -Description "Multimedia player"
    
    # ===================================================================
    # BROWSERS & WEB TOOLS
    # ===================================================================
    Write-Host "`n=== BROWSERS & WEB TOOLS ===" -ForegroundColor Magenta
    
    # Google Chrome
    Ask-InstallSoftware -SoftwareName "Google Chrome" -WingetID "Google.Chrome" -ChocoPackage "googlechrome" -Description "Web browser"
    
    # Mozilla Firefox
    Ask-InstallSoftware -SoftwareName "Mozilla Firefox" -WingetID "Mozilla.Firefox" -ChocoPackage "firefox" -Description "Web browser"
    
    # Postman
    Ask-InstallSoftware -SoftwareName "Postman" -WingetID "Postman.Postman" -ChocoPackage "postman" -Description "API development platform"
    
    # ===================================================================
    # ADDITIONAL UTILITIES
    # ===================================================================
    Write-Host "`n=== ADDITIONAL UTILITIES ===" -ForegroundColor Magenta
    
    # 7-Zip
    Ask-InstallSoftware -SoftwareName "7-Zip" -WingetID "7zip.7zip" -ChocoPackage "7zip" -Description "File archiver"
    
    # Everything Search
    Ask-InstallSoftware -SoftwareName "Everything" -WingetID "voidtools.Everything" -ChocoPackage "everything" -Description "Fast file search tool"
    
    # TreeSize Free
    Ask-InstallSoftware -SoftwareName "TreeSize Free" -WingetID "JAMSoftware.TreeSize.Free" -ChocoPackage "treesizefree" -Description "Disk space analyzer"
    
    # Windows Subsystem for Linux
    Write-Host "`nInstalling Windows Subsystem for Linux (WSL)..." -ForegroundColor Cyan
    try {
        wsl --install --no-launch
        Write-Host "WSL installation initiated. Please restart to complete installation." -ForegroundColor Yellow
    } catch {
        Write-Host "WSL installation failed. Please install manually via 'wsl --install'" -ForegroundColor Red
    }
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- WORK MODE SOFTWARE INSTALLATION ---" -ForegroundColor Cyan
    
    # Office 365 Enterprise - automatic installation for work
    Write-Host "Installing Office 365 Enterprise..." -ForegroundColor Yellow
    Install-Software -SoftwareName "Office 365 Enterprise" -WingetID "Microsoft.Office" -ChocoPackage "office365business" -Silent $true
    
    # Dell Command Update - automatic installation for work
    Write-Host "Installing Dell Command Update..." -ForegroundColor Yellow
    Install-Software -SoftwareName "Dell Command Update" -WingetID "Dell.CommandUpdate" -ChocoPackage "DellCommandUpdate" -Silent $true
    
    # Essential work tools
    Write-Host "Installing essential work tools..." -ForegroundColor Yellow
    Install-Software -SoftwareName "Windows Terminal" -WingetID "Microsoft.WindowsTerminal" -ChocoPackage "microsoft-windows-terminal" -Silent $true
    Install-Software -SoftwareName "PowerToys" -WingetID "Microsoft.PowerToys" -ChocoPackage "powertoys" -Silent $true
    Install-Software -SoftwareName "Sysinternals Suite" -WingetID "Microsoft.Sysinternals" -ChocoPackage "sysinternals" -Silent $true
    Install-Software -SoftwareName "Notepad++" -WingetID "Notepad++.Notepad++" -ChocoPackage "notepadplusplus" -Silent $true
    Install-Software -SoftwareName "7-Zip" -WingetID "7zip.7zip" -ChocoPackage "7zip" -Silent $true
}

# Alternative installations (commented out)
# choco install googlechrome -y --force --params "ALLUSERS=1" 
# choco install adobereader -y --force --params "ALLUSERS=1"

# ===================================================================
# COMPUTER NAMING
# ===================================================================

Write-Host "Configuring computer name..." -ForegroundColor Green

# Rename computer based on BIOS serial number
try {
    $compDetails = Get-ComputerInfo
    
    # Check if BIOS serial number is available and valid
    $biosSerial = $null
    if ($compDetails.BiosSeralNumber -and $compDetails.BiosSeralNumber.Trim() -ne "" -and $compDetails.BiosSeralNumber -ne "To be filled by O.E.M.") {
        $biosSerial = $compDetails.BiosSeralNumber.Trim()
    } elseif ($compDetails.BiosSerialNumber -and $compDetails.BiosSerialNumber.Trim() -ne "" -and $compDetails.BiosSerialNumber -ne "To be filled by O.E.M.") {
        # Try alternative property name (some systems use BiosSerialNumber instead of BiosSeralNumber)
        $biosSerial = $compDetails.BiosSerialNumber.Trim()
    } else {
        # Try WMI as fallback
        try {
            $wmiSerial = (Get-WmiObject -Class Win32_BIOS).SerialNumber
            if ($wmiSerial -and $wmiSerial.Trim() -ne "" -and $wmiSerial -ne "To be filled by O.E.M.") {
                $biosSerial = $wmiSerial.Trim()
                Write-Host "Using WMI BIOS serial number as fallback" -ForegroundColor Yellow
            }
        } catch {
            Write-Host "Could not retrieve BIOS serial via WMI" -ForegroundColor Yellow
        }
    }
    
    if ($biosSerial) {
        # Clean the serial number (remove special characters, spaces)
        $cleanSerial = $biosSerial -replace '[^\w]', ''
        
        # Limit length to avoid Windows computer name limitations (15 characters max)
        if ($cleanSerial.Length -gt 10) {
            $cleanSerial = $cleanSerial.Substring(0, 10)
        }
        
        $newName = "IE-$cleanSerial"
        $currentName = $compDetails.CsName
        
        Write-Host "Current computer name: $currentName" -ForegroundColor White
        Write-Host "BIOS Serial Number: $biosSerial" -ForegroundColor White
        Write-Host "Proposed new name: $newName" -ForegroundColor Cyan
        
        if ($currentName -ne $newName) {
            # Ask user for confirmation
            Write-Host "`n🖥️  COMPUTER NAME CHANGE" -ForegroundColor Yellow
            Write-Host "Do you want to rename the computer from '$currentName' to '$newName'?" -ForegroundColor White
            Write-Host "Note: This will require a restart to take effect." -ForegroundColor Yellow
            Write-Host "Proceed with rename? (y/n): " -NoNewline -ForegroundColor White
            $renameChoice = Read-Host
            
            if ($renameChoice -eq 'y' -or $renameChoice -eq 'Y' -or $renameChoice -eq 'yes') {
                try {
                    Rename-Computer -NewName $newName -Force
                    Write-Host "✅ Computer will be renamed to: $newName (restart required)" -ForegroundColor Green
                } catch {
                    Write-Host "❌ Failed to rename computer: $($_.Exception.Message)" -ForegroundColor Red
                    
                    # Try alternative method using WMI
                    try {
                        $computer = Get-WmiObject -Class Win32_ComputerSystem
                        $computer.Rename($newName)
                        Write-Host "✅ Computer rename scheduled via WMI: $newName (restart required)" -ForegroundColor Green
                    } catch {
                        Write-Host "❌ Alternative rename method also failed: $($_.Exception.Message)" -ForegroundColor Red
                    }
                }
            } else {
                Write-Host "Computer rename cancelled by user." -ForegroundColor Yellow
            }
        } else {
            Write-Host "✅ Computer name is already correct: $currentName" -ForegroundColor Green
        }
    } else {
        Write-Host "⚠️  BIOS serial number not available or invalid" -ForegroundColor Yellow
        Write-Host "Available BIOS information:" -ForegroundColor White
        Write-Host "  - BiosSeralNumber: '$($compDetails.BiosSeralNumber)'" -ForegroundColor Gray
        Write-Host "  - BiosSerialNumber: '$($compDetails.BiosSerialNumber)'" -ForegroundColor Gray
        
        # Try to get additional system information for alternative naming
        try {
            $systemInfo = Get-WmiObject -Class Win32_ComputerSystemProduct
            Write-Host "  - System Serial: '$($systemInfo.SerialNumber)'" -ForegroundColor Gray
            Write-Host "  - System UUID: '$($systemInfo.UUID)'" -ForegroundColor Gray
        } catch {
            Write-Host "  - Could not retrieve additional system information" -ForegroundColor Gray
        }
        
        Write-Host "`nWould you like to enter a custom computer name? (y/n): " -NoNewline -ForegroundColor White
        $customNameChoice = Read-Host
        
        if ($customNameChoice -eq 'y' -or $customNameChoice -eq 'Y' -or $customNameChoice -eq 'yes') {
            Write-Host "Enter new computer name (max 15 characters, letters/numbers only): " -NoNewline -ForegroundColor White
            $customName = Read-Host
            
            # Validate custom name
            if ($customName -and $customName.Length -le 15 -and $customName -match '^[a-zA-Z0-9-]+

# ===================================================================
# SYSTEM RESTART AND CLEANUP
# ===================================================================

Write-Host "Restarting Windows Explorer..." -ForegroundColor Green
# Restart Windows Explorer to apply UI changes
Get-Process explorer | Stop-Process -Force

# ===================================================================
# DIAGNOSTIC INFORMATION
# ===================================================================

Write-Host "Gathering startup program information..." -ForegroundColor Green
# Display startup programs for diagnostic purposes
Get-CimInstance Win32_StartupCommand | Select-Object Name, Command, Location, User | Format-List

# ===================================================================
# PRIVACY AND TELEMETRY CONFIGURATION
# ===================================================================

Write-Host "Configuring privacy settings and disabling telemetry..." -ForegroundColor Green

# Function to safely add registry entries
function Set-RegistryValue {
    param(
        [string]$Path,
        [string]$Name,
        [string]$Type,
        [string]$Value,
        [string]$Description = ""
    )
    
    Write-DetailedLog -Message "Setting registry value: $Path\$Name = $Value ($Type)" -Level "OPERATION" -Component "REGISTRY"
    
    try {
        # Convert registry path format
        $psPath = $Path -replace 'HKEY_LOCAL_MACHINE', 'HKLM:' -replace 'HKEY_CURRENT_USER', 'HKCU:'
        
        # Check if the registry path exists, create if it doesn't
        if (!(Test-Path $psPath)) {
            Write-DetailedLog -Message "Registry path does not exist, creating: $psPath" -Level "INFO" -Component "REGISTRY"
            $parentPath = Split-Path $psPath -Parent
            if (!(Test-Path $parentPath)) {
                # Create parent path if needed
                New-Item -Path $parentPath -Force | Out-Null
                Write-DetailedLog -Message "Created parent registry path: $parentPath" -Level "INFO" -Component "REGISTRY"
            }
            New-Item -Path $psPath -Force | Out-Null
            Write-DetailedLog -Message "Created registry path: $psPath" -Level "SUCCESS" -Component "REGISTRY"
            Write-Host "Created registry path: $psPath" -ForegroundColor Yellow
        }
        
        # Backup current value before changing
        try {
            $currentValue = Get-ItemProperty -Path $psPath -Name $Name -ErrorAction SilentlyContinue
            if ($currentValue) {
                Write-DetailedLog -Message "Current value backup: $Path\$Name = $($currentValue.$Name)" -Level "BACKUP" -Component "REGISTRY"
            }
        } catch {
            Write-DetailedLog -Message "No existing value to backup for: $Path\$Name" -Level "INFO" -Component "REGISTRY"
        }
        
        # Add the registry value
        reg add "$Path" /v "$Name" /t "$Type" /d "$Value" /f
        if ($LASTEXITCODE -eq 0) {
            Write-DetailedLog -Message "Successfully set registry value: $Path\$Name = $Value" -Level "SUCCESS" -Component "REGISTRY"
            Write-Host "✓ Set registry: $Path\$Name = $Value" -ForegroundColor Green
            if ($Description) {
                Write-DetailedLog -Message "Registry value purpose: $Description" -Level "INFO" -Component "REGISTRY"
                Write-Host "  Purpose: $Description" -ForegroundColor Gray
            }
        } else {
            Write-DetailedLog -Message "Failed to set registry value (exit code: $LASTEXITCODE): $Path\$Name" -Level "ERROR" -Component "REGISTRY"
            Write-Host "✗ Failed to set registry: $Path\$Name" -ForegroundColor Red
        }
    } catch {
        Write-DetailedLog -Message "Registry operation exception: $Path\$Name - $($_.Exception.Message)" -Level "ERROR" -Component "REGISTRY"
        Write-Host "✗ Registry error for $Path\$Name : $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Disable Windows telemetry and data collection
Write-Host "`nDisabling telemetry and data collection..." -ForegroundColor Yellow

Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" -Name "AllowTelemetry" -Type "REG_DWORD" -Value "0" -Description "Disable telemetry data collection"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection" -Name "AllowTelemetry" -Type "REG_DWORD" -Value "0" -Description "Disable telemetry (alternative path)"

# Disable diagnostic data
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Diagnostics\DiagTrack" -Name "ShowedToastAtLevel" -Type "REG_DWORD" -Value "1" -Description "Disable diagnostic tracking toast"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" -Name "AllowDeviceNameInTelemetry" -Type "REG_DWORD" -Value "0" -Description "Disable device name in telemetry"

# Disable Windows Error Reporting
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting" -Name "Disabled" -Type "REG_DWORD" -Value "1" -Description "Disable Windows Error Reporting"

# Disable Customer Experience Improvement Program
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\SQMClient\Windows" -Name "CEIPEnable" -Type "REG_DWORD" -Value "0" -Description "Disable Customer Experience Improvement Program"

# Disable Application Compatibility Telemetry
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" -Name "AITEnable" -Type "REG_DWORD" -Value "0" -Description "Disable Application Compatibility Telemetry"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" -Name "DisableInventory" -Type "REG_DWORD" -Value "1" -Description "Disable application inventory"

# Disable Windows Defender submission of samples
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Name "SubmitSamplesConsent" -Type "REG_DWORD" -Value "2" -Description "Disable sample submission"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Name "SpynetReporting" -Type "REG_DWORD" -Value "0" -Description "Disable SpyNet reporting"

# Disable activity history
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" -Name "EnableActivityFeed" -Type "REG_DWORD" -Value "0" -Description "Disable activity feed"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" -Name "PublishUserActivities" -Type "REG_DWORD" -Value "0" -Description "Disable publishing user activities"

# Disable location tracking
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\LocationAndSensors" -Name "DisableLocation" -Type "REG_DWORD" -Value "1" -Description "Disable location services"
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\location" -Name "Value" -Type "REG_SZ" -Value "Deny" -Description "Deny location access"

# Disable advertising ID
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AdvertisingInfo" -Name "DisabledByGroupPolicy" -Type "REG_DWORD" -Value "1" -Description "Disable advertising ID"
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\AdvertisingInfo" -Name "Enabled" -Type "REG_DWORD" -Value "0" -Description "Disable advertising ID for user"

# Disable sync with Microsoft services
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\SettingSync" -Name "SyncPolicy" -Type "REG_DWORD" -Value "5" -Description "Disable settings sync"

# ===================================================================
# ADVANCED PERFORMANCE OPTIMIZATION
# ===================================================================

Write-Host "Applying advanced performance optimizations..." -ForegroundColor Green

# Disable Windows Search indexing service (alternative method)
# Note: This is now handled in the services section above

# Disable SuperFetch/SysMain (can slow down SSDs)
# Note: This is now handled in the services section above

# Disable Windows Update automatic restart
Write-Host "`nConfiguring Windows Update settings..." -ForegroundColor Yellow
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "NoAutoRebootWithLoggedOnUsers" -Type "REG_DWORD" -Value "1" -Description "Prevent automatic restart with logged on users"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "AUPowerManagement" -Type "REG_DWORD" -Value "0" -Description "Disable automatic power management for updates"

# Optimize visual effects for performance
Write-Host "`nOptimizing visual effects..." -ForegroundColor Yellow
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VisualEffects" -Name "VisualFXSetting" -Type "REG_DWORD" -Value "2" -Description "Set visual effects for best performance"

# Disable unnecessary animations
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Desktop" -Name "MenuShowDelay" -Type "REG_SZ" -Value "0" -Description "Remove menu show delay"
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics" -Name "MinAnimate" -Type "REG_SZ" -Value "0" -Description "Disable window animations"

# Set processor scheduling for background services
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\PriorityControl" -Name "Win32PrioritySeparation" -Type "REG_DWORD" -Value "24" -Description "Optimize processor scheduling for background services"

# Disable memory compression (Windows 10/11)
Write-Host "`nConfiguring memory compression..." -ForegroundColor Yellow
$memoryChoice = Read-Host "Do you want to disable memory compression? May improve performance on systems with sufficient RAM. (y/n)"
if ($memoryChoice -eq 'y' -or $memoryChoice -eq 'Y' -or $memoryChoice -eq 'yes') {
    try {
        Disable-MMAgent -MemoryCompression
        Write-Host "✓ Memory compression disabled" -ForegroundColor Green
    } catch {
        Write-Host "⚠ Could not disable memory compression: $($_.Exception.Message)" -ForegroundColor Yellow
    }
} else {
    Write-Host "Memory compression will remain enabled" -ForegroundColor Green
}

# Set paging file to system managed on C: drive only
Write-Host "`nConfiguring paging file..." -ForegroundColor Yellow
try {
    $cs = Get-WmiObject -Class Win32_ComputerSystem
    if ($cs.AutomaticManagedPagefile) {
        $pagingChoice = Read-Host "Do you want to let the system manage the paging file automatically? (y/n)"
        if ($pagingChoice -eq 'n' -or $pagingChoice -eq 'N' -or $pagingChoice -eq 'no') {
            $cs.AutomaticManagedPagefile = $false
            $cs.Put()
            Write-Host "✓ Automatic paging file management disabled" -ForegroundColor Yellow
            Write-Host "You may want to manually configure paging file settings" -ForegroundColor Gray
        }
    } else {
        Write-Host "Paging file is already manually managed" -ForegroundColor Green
    }
} catch {
    Write-Host "⚠ Could not configure paging file settings: $($_.Exception.Message)" -ForegroundColor Yellow
}

# ===================================================================
# SECURITY ENHANCEMENTS
# ===================================================================

Write-Host "Applying security enhancements..." -ForegroundColor Green

# Disable Guest account
try {
    Disable-LocalUser -Name "Guest"
    Write-Host "Guest account disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Guest account not found or already disabled" -ForegroundColor Yellow
}

# Enable UAC but reduce prompts for admins
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 2 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v PromptOnSecureDesktop /t REG_DWORD /d 0 /f

# Disable AutoRun for removable media
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v NoDriveTypeAutoRun /t REG_DWORD /d 255 /f

# Set strong password policy
net accounts /minpwlen:8 /maxpwage:90 /lockoutthreshold:5 /lockoutduration:30

# Disable SMB1 protocol (security vulnerability)
try {
    Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -NoRestart
    Write-Host "SMB1 protocol disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable SMB1 protocol" -ForegroundColor Red
}

# ===================================================================
# NETWORK AND INTERNET OPTIMIZATION
# ===================================================================

Write-Host "Optimizing network settings..." -ForegroundColor Green

# Disable Windows Update P2P sharing
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\DeliveryOptimization\Config" /v DODownloadMode /t REG_DWORD /d 0 /f

# Set DNS to Cloudflare (1.1.1.1) for better performance and privacy
try {
    $adapters = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
    foreach ($adapter in $adapters) {
        Set-DnsClientServerAddress -InterfaceAlias $adapter.Name -ServerAddresses "1.1.1.1", "1.0.0.1"
    }
    Write-Host "DNS set to Cloudflare (1.1.1.1, 1.0.0.1)" -ForegroundColor Green
} catch {
    Write-Host "Could not set DNS servers" -ForegroundColor Red
}

# Disable Teredo tunneling (can be security risk)
netsh interface teredo set state disabled

# Disable Windows Connect Now
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v EnableRegistrars /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v DisableUPnPRegistrar /t REG_DWORD /d 0 /f

# ===================================================================
# STARTUP AND SERVICES OPTIMIZATION
# ===================================================================

Write-Host "Optimizing startup and services..." -ForegroundColor Green

# Function to safely disable Windows services
function Disable-WindowsService {
    param(
        [string]$ServiceName,
        [string]$Description = ""
    )
    
    try {
        $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if ($serviceObj) {
            Write-Host "Processing service: $ServiceName" -ForegroundColor Cyan
            
            # Display current status
            Write-Host "  Current status: $($serviceObj.Status)" -ForegroundColor Gray
            Write-Host "  Startup type: $($serviceObj.StartType)" -ForegroundColor Gray
            if ($Description) {
                Write-Host "  Purpose: $Description" -ForegroundColor Gray
            }
            
            # Stop the service if it's running
            if ($serviceObj.Status -eq 'Running') {
                Write-Host "  Stopping service..." -ForegroundColor Yellow
                Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 1  # Brief pause to allow service to stop
                
                # Verify service stopped
                $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
                if ($serviceObj.Status -eq 'Stopped') {
                    Write-Host "  ✓ Service stopped successfully" -ForegroundColor Green
                } else {
                    Write-Host "  ⚠ Service may still be running" -ForegroundColor Yellow
                }
            }
            
            # Disable the service
            Write-Host "  Setting startup type to Disabled..." -ForegroundColor Yellow
            Set-Service -Name $ServiceName -StartupType Disabled -ErrorAction SilentlyContinue
            
            # Verify the change
            $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
            if ($serviceObj.StartType -eq 'Disabled') {
                Write-Host "  ✓ Service disabled successfully: $ServiceName" -ForegroundColor Green
            } else {
                Write-Host "  ⚠ Service may not be properly disabled: $ServiceName" -ForegroundColor Yellow
            }
        } else {
            Write-Host "⚠ Service not found: $ServiceName" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "✗ Error processing service $ServiceName : $($_.Exception.Message)" -ForegroundColor Red
    }
}

# List of services to disable for better performance
Write-Host "`nDisabling unnecessary services..." -ForegroundColor Yellow

$servicesToDisable = @(
    @{ Name = "Fax"; Description = "Fax service - rarely used in modern environments" },
    @{ Name = "WMPNetworkSvc"; Description = "Windows Media Player Network Sharing Service" },
    @{ Name = "TabletInputService"; Description = "Tablet PC Input Service - not needed on desktop PCs" },
    @{ Name = "TrkWks"; Description = "Distributed Link Tracking Client - tracks file shortcuts" },
    @{ Name = "WerSvc"; Description = "Windows Error Reporting Service" },
    @{ Name = "DiagTrack"; Description = "Connected User Experiences and Telemetry" },
    @{ Name = "dmwappushservice"; Description = "WAP Push Message Routing Service - mobile networks" },
    @{ Name = "MapsBroker"; Description = "Downloaded Maps Manager" },
    @{ Name = "lfsvc"; Description = "Geolocation Service" },
    @{ Name = "RetailDemo"; Description = "Retail Demo Service - used in store displays" },
    @{ Name = "RemoteRegistry"; Description = "Remote Registry - security risk if not needed" },
    @{ Name = "SharedAccess"; Description = "Internet Connection Sharing (ICS)" },
    @{ Name = "SSDPSRV"; Description = "SSDP Discovery - UPnP device discovery" },
    @{ Name = "upnphost"; Description = "UPnP Device Host" },
    @{ Name = "WSearch"; Description = "Windows Search - will be handled separately" }
)

foreach ($service in $servicesToDisable) {
    Disable-WindowsService -ServiceName $service.Name -Description $service.Description
}

# Special handling for Windows Search service
Write-Host "`nHandling Windows Search service..." -ForegroundColor Yellow
$searchChoice = Read-Host "Do you want to disable Windows Search indexing? This will improve performance but slow down file searches. (y/n)"
if ($searchChoice -eq 'y' -or $searchChoice -eq 'Y' -or $searchChoice -eq 'yes') {
    Disable-WindowsService -ServiceName "WSearch" -Description "Windows Search indexing service"
} else {
    Write-Host "Windows Search service will remain enabled" -ForegroundColor Green
}

# Special handling for SuperFetch/SysMain
Write-Host "`nHandling SysMain (SuperFetch) service..." -ForegroundColor Yellow
$sysmainChoice = Read-Host "Do you want to disable SysMain (SuperFetch)? Recommended for SSDs. (y/n)"
if ($sysmainChoice -eq 'y' -or $sysmainChoice -eq 'Y' -or $sysmainChoice -eq 'yes') {
    Disable-WindowsService -ServiceName "SysMain" -Description "System Maintenance service (SuperFetch) - can slow down SSDs"
} else {
    Write-Host "SysMain service will remain enabled" -ForegroundColor Green
}

# ===================================================================
# REGISTRY CLEANUP AND OPTIMIZATION
# ===================================================================

Write-Host "Performing registry optimizations..." -ForegroundColor Green

# Disable Windows Tips and Tricks
Write-Host "`nDisabling Windows tips and consumer features..." -ForegroundColor Yellow
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" -Name "SoftLandingEnabled" -Type "REG_DWORD" -Value "0" -Description "Disable soft landing tips"
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" -Name "SystemPaneSuggestionsEnabled" -Type "REG_DWORD" -Value "0" -Description "Disable system pane suggestions"

# Disable consumer features (suggested apps)
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CloudContent" -Name "DisableWindowsConsumerFeatures" -Type "REG_DWORD" -Value "1" -Description "Disable Windows consumer features and app suggestions"

# Disable Windows Ink workspace
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsInkWorkspace" -Name "AllowWindowsInkWorkspace" -Type "REG_DWORD" -Value "0" -Description "Disable Windows Ink workspace"

# Disable People icon in taskbar
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\People" -Name "PeopleBand" -Type "REG_DWORD" -Value "0" -Description "Hide People icon from taskbar"

# Disable Sticky Keys prompt
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Accessibility\StickyKeys" -Name "Flags" -Type "REG_SZ" -Value "506" -Description "Disable Sticky Keys prompt"

# Disable Filter Keys prompt  
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Accessibility\Keyboard Response" -Name "Flags" -Type "REG_SZ" -Value "122" -Description "Disable Filter Keys prompt"

# Disable Toggle Keys prompt
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Accessibility\ToggleKeys" -Name "Flags" -Type "REG_SZ" -Value "58" -Description "Disable Toggle Keys prompt"

# ===================================================================
# ADDITIONAL SOFTWARE MANAGEMENT
# ===================================================================

Write-Host "Managing additional software..." -ForegroundColor Green

# List of built-in apps to remove (Windows 10/11 bloatware)
$appsToRemove = @(
    "Microsoft.3DBuilder",
    "Microsoft.BingFinance",
    "Microsoft.BingNews", 
    "Microsoft.BingSports",
    "Microsoft.BingWeather",
    "Microsoft.GetHelp",
    "Microsoft.Getstarted",
    "Microsoft.Messaging",
    "Microsoft.Microsoft3DViewer",
    "Microsoft.MicrosoftOfficeHub",
    "Microsoft.MicrosoftSolitaireCollection",
    "Microsoft.NetworkSpeedTest",
    "Microsoft.News",
    "Microsoft.Office.Lens",
    "Microsoft.Office.OneNote",
    "Microsoft.Office.Sway",
    "Microsoft.OneConnect",
    "Microsoft.People",
    "Microsoft.Print3D",
    "Microsoft.RemoteDesktop",
    "Microsoft.SkypeApp",
    "Microsoft.Wallet",
    "Microsoft.Whiteboard",
    "Microsoft.WindowsAlarms",
    "Microsoft.WindowsCamera",
    "microsoft.windowscommunicationsapps",
    "Microsoft.WindowsFeedbackHub",
    "Microsoft.WindowsMaps",
    "Microsoft.WindowsSoundRecorder",
    "Microsoft.Xbox.TCUI",
    "Microsoft.XboxApp",
    "Microsoft.XboxGameOverlay",
    "Microsoft.XboxGamingOverlay",
    "Microsoft.XboxIdentityProvider",
    "Microsoft.XboxSpeechToTextOverlay",
    "Microsoft.ZuneMusic",
    "Microsoft.ZuneVideo"
)

foreach ($app in $appsToRemove) {
    try {
        Get-AppxPackage -Name $app -AllUsers | Remove-AppxPackage -ErrorAction SilentlyContinue
        Get-AppxProvisionedPackage -Online | Where-Object DisplayName -like $app | Remove-AppxProvisionedPackage -Online -ErrorAction SilentlyContinue
        Write-Host "Removed app: $app" -ForegroundColor Yellow
    } catch {
        # Silently continue if app is not found
    }
}

# ===================================================================
# DISK CLEANUP AND MAINTENANCE
# ===================================================================

Write-Host "Performing disk cleanup..." -ForegroundColor Green

# Clean temporary files
Remove-Item -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "$env:LOCALAPPDATA\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue

# Clear Windows Update cache
try {
    Stop-Service wuauserv -Force
    Remove-Item -Path "$env:WINDIR\SoftwareDistribution\Download\*" -Recurse -Force -ErrorAction SilentlyContinue
    Start-Service wuauserv
    Write-Host "Windows Update cache cleared" -ForegroundColor Yellow
} catch {
    Write-Host "Could not clear Windows Update cache" -ForegroundColor Red
}

# Enable Storage Sense (automatic cleanup)
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy" /v 01 /t REG_DWORD /d 1 /f

# ===================================================================
# ROLLBACK SYSTEM
# ===================================================================

function Get-CurrentlyInstalledApplications {
    Write-Host "Scanning currently installed applications..." -ForegroundColor Cyan
    
    $currentApps = @{}
    
    # Get currently installed software using the same methods as discovery
    try {
        # Registry 64-bit
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg64) {
            $currentApps[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
        
        # Registry 32-bit
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $currentApps.ContainsKey($app.DisplayName)) {
                $currentApps[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
        
        # Store Apps
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            if (-not $currentApps.ContainsKey($app.Name)) {
                $currentApps[$app.Name] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
        
        Write-Host "Found $($currentApps.Count) currently installed applications" -ForegroundColor Green
        return $currentApps
        
    } catch {
        Write-Host "Error scanning installed applications: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Find-AvailableBackups {
    param([string]$BackupBasePath)
    
    Write-Host "Searching for available backups in: $BackupBasePath" -ForegroundColor Cyan
    
    if (!(Test-Path $BackupBasePath)) {
        Write-Host "Backup base path does not exist: $BackupBasePath" -ForegroundColor Red
        return @{}
    }
    
    $availableBackups = @{}
    
    try {
        # Find all backup sessions (timestamp directories)
        $backupSessions = Get-ChildItem $BackupBasePath -Directory | 
            Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "`n💾 BACKUP/RESTORE INFORMATION:" -ForegroundColor Yellow
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    if ($Restore) {
        Write-Host "• Interactive restore: Current configs backed up before restore" -ForegroundColor White
        Write-Host "• Restore logs available in backup base path" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White
Write-Host "Restore configurations: .\script.ps1 -Mode home -Restore" -ForegroundColor White
Write-Host "Restore with custom path: .\script.ps1 -Mode home -Restore -BackupBasePath 'D:\MyBackups'" -ForegroundColor White
Write-Host "System rollback: .\script.ps1 -Mode home -Rollback" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore -or $Rollback) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    if (-not $Restore -and -not $Rollback) {
        Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    }
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
    Write-Host "System Backups: BackupBasePath\SystemBackup_YYYY-MM-DD_HH-MM-SS\" -ForegroundColor Gray
    if ($Restore) {
        Write-Host "Before-restore backups: BackupBasePath\beforeRestoreBackup_YYYY-MM-DD_HH-MM-SS\[AppName]" -ForegroundColor Gray
    }
    Write-Host "Logs: BackupBasePath\WindowsConfigScript_log_YYYY-MM-DD_HH-MM-SS.log" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow

# Final logging
End-OperationLog -OperationName "WindowsConfigurationScript" -Success $true
Write-DetailedLog -Message "Script execution completed. Log file: $LogPath" -Level "SUCCESS"
Write-DetailedLog -Message "=== END OF LOG ===" -Level "INFO"

Write-Host "==================================================================" -ForegroundColor Cyan } |
            Sort-Object Name -Descending
        
        foreach ($session in $backupSessions) {
            $sessionPath = $session.FullName
            $sessionName = $session.Name
            
            # Check for StandardSoftwareBackup
            $standardBackupPath = Join-Path $sessionPath "StandardSoftwareBackup\AppData"
            if (Test-Path $standardBackupPath) {
                $standardApps = Get-ChildItem $standardBackupPath -Directory
                foreach ($app in $standardApps) {
                    $appName = $app.Name
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Standard"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
            
            # Check for ComprehensiveSoftwareBackup
            $comprehensiveBackupPath = Join-Path $sessionPath "ComprehensiveSoftwareBackup\Applications"
            if (Test-Path $comprehensiveBackupPath) {
                $comprehensiveApps = Get-ChildItem $comprehensiveBackupPath -Directory
                foreach ($app in $comprehensiveApps) {
                    $appName = $app.Name -replace '_', ' '  # Restore original name format
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Comprehensive"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
        }
        
        Write-Host "Found backups for $($availableBackups.Count) applications across $($backupSessions.Count) sessions" -ForegroundColor Green
        return $availableBackups
        
    } catch {
        Write-Host "Error searching for backups: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Backup-CurrentConfiguration {
    param(
        [string]$AppName,
        [string]$RestoreBackupPath,
        [string]$BackupBasePath
    )
    
    try {
        # Create beforeRestore backup directory
        $beforeRestoreTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
        $beforeRestorePath = "$BackupBasePath\beforeRestoreBackup_$beforeRestoreTimestamp\$($AppName -replace '[^\w\s-]', '_')"
        New-Item -Path $beforeRestorePath -ItemType Directory -Force | Out-Null
        
        # Get current configuration paths for the application
        $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
        
        $backupSuccess = $false
        
        # Backup current configuration files
        foreach ($configPath in $paths.ConfigPaths) {
            try {
                if (Test-Path $configPath) {
                    $destinationPath = Join-Path $beforeRestorePath (Split-Path $configPath -Leaf)
                    if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                        Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force
                    } else {
                        Copy-Item -Path $configPath -Destination $destinationPath -Force
                    }
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current: $(Split-Path $configPath -Leaf)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup: $configPath" -ForegroundColor Yellow
            }
        }
        
        # Backup current registry keys
        foreach ($regPath in $paths.RegistryPaths) {
            try {
                $regFileName = "$beforeRestorePath\$($AppName -replace '[^\w\s-]', '_')_current_registry.reg"
                reg export "$regPath" "$regFileName" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current registry: $regPath" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup registry: $regPath" -ForegroundColor Yellow
            }
        }
        
        if ($backupSuccess) {
            # Create metadata file
            $metadata = @{
                AppName = $AppName
                BackupDate = Get-Date
                RestoreSource = $RestoreBackupPath
                Purpose = "BeforeRestore"
            }
            $metadata | ConvertTo-Json | Out-File "$beforeRestorePath\backup_metadata.json" -Encoding UTF8
            
            Write-Host "✅ Current configuration backed up to: $beforeRestorePath" -ForegroundColor Green
            return $beforeRestorePath
        } else {
            Write-Host "⚠ No current configuration found to backup for: $AppName" -ForegroundColor Yellow
            return $null
        }
        
    } catch {
        Write-Host "❌ Failed to backup current configuration: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Restore-ApplicationConfiguration {
    param(
        [string]$AppName,
        [string]$BackupPath,
        [string]$BackupBasePath
    )
    
    Write-Host "`n🔄 RESTORING CONFIGURATION FOR: $AppName" -ForegroundColor Cyan
    Write-Host "From backup: $BackupPath" -ForegroundColor Gray
    
    try {
        # First, backup current configuration
        Write-Host "`n📦 Creating backup of current configuration..." -ForegroundColor Yellow
        $beforeRestoreBackup = Backup-CurrentConfiguration -AppName $AppName -RestoreBackupPath $BackupPath -BackupBasePath $BackupBasePath
        
        $restoreSuccess = $false
        $restoredItems = @()
        
        # Restore configuration files
        Write-Host "`n📂 Restoring configuration files..." -ForegroundColor Yellow
        $configFiles = Get-ChildItem $BackupPath -File | Where-Object { $_.Name -notlike "*.reg" -and $_.Name -ne "backup_metadata.json" }
        
        foreach ($file in $configFiles) {
            try {
                # Try to determine target path based on file name and application
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetFile = Join-Path $parentDir $file.Name
                        Copy-Item -Path $file.FullName -Destination $targetFile -Force
                        Write-Host "✓ Restored: $($file.Name) → $targetFile" -ForegroundColor Green
                        $restoredItems += $targetFile
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for: $($file.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore: $($file.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore configuration directories
        $configDirs = Get-ChildItem $BackupPath -Directory
        foreach ($dir in $configDirs) {
            try {
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetDir = Join-Path $parentDir $dir.Name
                        Copy-Item -Path $dir.FullName -Destination $targetDir -Recurse -Force
                        Write-Host "✓ Restored directory: $($dir.Name) → $targetDir" -ForegroundColor Green
                        $restoredItems += $targetDir
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for directory: $($dir.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore directory: $($dir.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore registry entries
        Write-Host "`n🔧 Restoring registry entries..." -ForegroundColor Yellow
        $regFiles = Get-ChildItem $BackupPath -Filter "*.reg"
        
        foreach ($regFile in $regFiles) {
            try {
                Write-Host "Importing registry: $($regFile.Name)" -ForegroundColor Cyan
                reg import "$($regFile.FullName)" /reg:64
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Registry imported: $($regFile.Name)" -ForegroundColor Green
                    $restoredItems += $regFile.FullName
                    $restoreSuccess = $true
                } else {
                    Write-Host "✗ Registry import failed: $($regFile.Name)" -ForegroundColor Red
                }
            } catch {
                Write-Host "✗ Registry import error: $($regFile.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Create restore log
        if ($restoreSuccess) {
            $restoreLog = @{
                AppName = $AppName
                RestoreDate = Get-Date
                SourceBackup = $BackupPath
                BeforeRestoreBackup = $beforeRestoreBackup
                RestoredItems = $restoredItems
                Status = "Success"
            }
            
            $logPath = "$BackupBasePath\restore_log_$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss').json"
            $restoreLog | ConvertTo-Json -Depth 3 | Out-File $logPath -Encoding UTF8
            
            Write-Host "`n✅ RESTORE COMPLETED SUCCESSFULLY" -ForegroundColor Green
            Write-Host "Restored items: $($restoredItems.Count)" -ForegroundColor White
            Write-Host "Restore log: $logPath" -ForegroundColor White
            if ($beforeRestoreBackup) {
                Write-Host "Current config backed up to: $beforeRestoreBackup" -ForegroundColor White
            }
            
            return $true
        } else {
            Write-Host "`n❌ RESTORE FAILED - No items were successfully restored" -ForegroundColor Red
            return $false
        }
        
    } catch {
        Write-Host "`n❌ RESTORE ERROR: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

function Start-ConfigurationRestore {
    param([string]$BackupBasePath)
    
    Write-Host "`n🔄 CONFIGURATION RESTORE MODE" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    
    # Get currently installed applications
    $currentApps = Get-CurrentlyInstalledApplications
    if ($currentApps.Count -eq 0) {
        Write-Host "No installed applications found. Cannot proceed with restore." -ForegroundColor Red
        return
    }
    
    # Find available backups
    $availableBackups = Find-AvailableBackups -BackupBasePath $BackupBasePath
    if ($availableBackups.Count -eq 0) {
        Write-Host "No configuration backups found in: $BackupBasePath" -ForegroundColor Red
        return
    }
    
    # Find applications that are both installed and have backups
    $restorableApps = @{}
    foreach ($appName in $availableBackups.Keys) {
        # Try to match app names (exact match or partial match)
        $matchingApp = $null
        foreach ($installedApp in $currentApps.Keys) {
            if ($installedApp -eq $appName -or 
                $installedApp -like "*$appName*" -or 
                $appName -like "*$installedApp*") {
                $matchingApp = $installedApp
                break
            }
        }
        
        if ($matchingApp) {
            $restorableApps[$appName] = @{
                InstalledName = $matchingApp
                Backups = $availableBackups[$appName]
            }
        }
    }
    
    if ($restorableApps.Count -eq 0) {
        Write-Host "No restorable applications found." -ForegroundColor Yellow
        Write-Host "This means no installed applications have available configuration backups." -ForegroundColor Yellow
        return
    }
    
    Write-Host "`n📋 RESTORABLE APPLICATIONS:" -ForegroundColor Green
    Write-Host "Found $($restorableApps.Count) applications with available backups" -ForegroundColor White
    
    # Display restorable applications
    $appIndex = 1
    $appList = @()
    foreach ($app in $restorableApps.GetEnumerator()) {
        $appList += $app
        Write-Host "$appIndex. $($app.Key) ($($app.Value.Backups.Count) backup(s) available)" -ForegroundColor Cyan
        $appIndex++
    }
    
    # Application selection loop
    do {
        Write-Host "`n🎯 SELECT APPLICATION TO RESTORE:" -ForegroundColor Yellow
        Write-Host "Enter application number (1-$($appList.Count)) or 'q' to quit: " -NoNewline
        $selection = Read-Host
        
        if ($selection -eq 'q' -or $selection -eq 'Q') {
            Write-Host "Restore cancelled by user." -ForegroundColor Yellow
            return
        }
        
        if ($selection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$selection -ge 1 -and [int]$selection -le $appList.Count) {
            $selectedApp = $appList[[int]$selection - 1]
            $appName = $selectedApp.Key
            $appBackups = $selectedApp.Value.Backups
            
            Write-Host "`n📦 AVAILABLE BACKUPS FOR: $appName" -ForegroundColor Cyan
            
            # Display available backups
            $backupIndex = 1
            foreach ($backup in $appBackups) {
                Write-Host "$backupIndex. Session: $($backup.Session) | Type: $($backup.Type) | Date: $($backup.BackupDate)" -ForegroundColor White
                $backupIndex++
            }
            
            # Backup selection
            Write-Host "`nSelect backup number (1-$($appBackups.Count)) or 'b' to go back: " -NoNewline
            $backupSelection = Read-Host
            
            if ($backupSelection -eq 'b' -or $backupSelection -eq 'B') {
                continue  # Go back to app selection
            }
            
            if ($backupSelection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$backupSelection -ge 1 -and [int]$backupSelection -le $appBackups.Count) {
                $selectedBackup = $appBackups[[int]$backupSelection - 1]
                
                Write-Host "`n⚠️  CONFIRMATION REQUIRED" -ForegroundColor Yellow
                Write-Host "You are about to restore configuration for: $appName" -ForegroundColor White
                Write-Host "From backup: $($selectedBackup.Session) ($($selectedBackup.Type))" -ForegroundColor White
                Write-Host "Current configuration will be backed up before restore." -ForegroundColor White
                Write-Host "`nProceed with restore? (y/n): " -NoNewline
                $confirm = Read-Host
                
                if ($confirm -eq 'y' -or $confirm -eq 'Y' -or $confirm -eq 'yes') {
                    $restoreResult = Restore-ApplicationConfiguration -AppName $appName -BackupPath $selectedBackup.Path -BackupBasePath $BackupBasePath
                    
                    if ($restoreResult) {
                        Write-Host "`n🎉 Configuration restored successfully!" -ForegroundColor Green
                        Write-Host "You may need to restart the application to see changes." -ForegroundColor Yellow
                    } else {
                        Write-Host "`n💥 Configuration restore failed!" -ForegroundColor Red
                    }
                    
                    Write-Host "`nRestore another application? (y/n): " -NoNewline
                    $continueRestore = Read-Host
                    if ($continueRestore -ne 'y' -and $continueRestore -ne 'Y' -and $continueRestore -ne 'yes') {
                        break
                    }
                } else {
                    Write-Host "Restore cancelled." -ForegroundColor Yellow
                }
            } else {
                Write-Host "Invalid backup selection." -ForegroundColor Red
            }
        } else {
            Write-Host "Invalid application selection." -ForegroundColor Red
        }
    } while ($true)
    
    Write-Host "`n✅ RESTORE SESSION COMPLETED" -ForegroundColor Green
}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan) {
                $currentName = $compDetails.CsName
                if ($currentName -ne $customName) {
                    try {
                        Rename-Computer -NewName $customName -Force
                        Write-Host "✅ Computer will be renamed to: $customName (restart required)" -ForegroundColor Green
                    } catch {
                        Write-Host "❌ Failed to rename computer: $($_.Exception.Message)" -ForegroundColor Red
                    }
                } else {
                    Write-Host "Computer name is already: $customName" -ForegroundColor Yellow
                }
            } else {
                Write-Host "❌ Invalid computer name. Must be 1-15 characters, letters/numbers/hyphens only." -ForegroundColor Red
            }
        } else {
            Write-Host "Computer name will remain unchanged: $($compDetails.CsName)" -ForegroundColor Yellow
        }
    }
    
} catch {
    Write-Host "❌ Error configuring computer name: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Computer name will remain unchanged." -ForegroundColor Yellow
}

# ===================================================================
# SYSTEM RESTART AND CLEANUP
# ===================================================================

Write-Host "Restarting Windows Explorer..." -ForegroundColor Green
# Restart Windows Explorer to apply UI changes
Get-Process explorer | Stop-Process -Force

# ===================================================================
# DIAGNOSTIC INFORMATION
# ===================================================================

Write-Host "Gathering startup program information..." -ForegroundColor Green
# Display startup programs for diagnostic purposes
Get-CimInstance Win32_StartupCommand | Select-Object Name, Command, Location, User | Format-List

# ===================================================================
# PRIVACY AND TELEMETRY CONFIGURATION
# ===================================================================

Write-Host "Configuring privacy settings and disabling telemetry..." -ForegroundColor Green

# Disable Windows telemetry and data collection
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f

# Disable diagnostic data
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Diagnostics\DiagTrack" /v ShowedToastAtLevel /t REG_DWORD /d 1 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" /v AllowDeviceNameInTelemetry /t REG_DWORD /d 0 /f

# Disable Windows Error Reporting
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting" /v Disabled /t REG_DWORD /d 1 /f

# Disable Customer Experience Improvement Program
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\SQMClient\Windows" /v CEIPEnable /t REG_DWORD /d 0 /f

# Disable Application Compatibility Telemetry
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" /v AITEnable /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" /v DisableInventory /t REG_DWORD /d 1 /f

# Disable Windows Defender submission of samples
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v SubmitSamplesConsent /t REG_DWORD /d 2 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v SpynetReporting /t REG_DWORD /d 0 /f

# Disable activity history
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" /v EnableActivityFeed /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" /v PublishUserActivities /t REG_DWORD /d 0 /f

# Disable location tracking
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\LocationAndSensors" /v DisableLocation /t REG_DWORD /d 1 /f
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\location" /v Value /t REG_SZ /d "Deny" /f

# Disable advertising ID
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AdvertisingInfo" /v DisabledByGroupPolicy /t REG_DWORD /d 1 /f
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\AdvertisingInfo" /v Enabled /t REG_DWORD /d 0 /f

# Disable sync with Microsoft services
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\SettingSync" /v SyncPolicy /t REG_DWORD /d 5 /f

# ===================================================================
# ADVANCED PERFORMANCE OPTIMIZATION
# ===================================================================

Write-Host "Applying advanced performance optimizations..." -ForegroundColor Green

# Disable Windows Search indexing service (alternative method)
try {
    Stop-Service "WSearch" -Force
    Set-Service "WSearch" -StartupType Disabled
    Write-Host "Windows Search service disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable Windows Search service" -ForegroundColor Red
}

# Disable SuperFetch/SysMain (can slow down SSDs)
try {
    Stop-Service "SysMain" -Force
    Set-Service "SysMain" -StartupType Disabled
    Write-Host "SysMain (SuperFetch) service disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable SysMain service" -ForegroundColor Red
}

# Disable Windows Update automatic restart
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" /v NoAutoRebootWithLoggedOnUsers /t REG_DWORD /d 1 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" /v AUPowerManagement /t REG_DWORD /d 0 /f

# Optimize visual effects for performance
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VisualEffects" /v VisualFXSetting /t REG_DWORD /d 2 /f

# Disable unnecessary animations
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v MenuShowDelay /t REG_SZ /d "0" /f
reg add "HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics" /v MinAnimate /t REG_SZ /d "0" /f

# Set processor scheduling for background services
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\PriorityControl" /v Win32PrioritySeparation /t REG_DWORD /d 24 /f

# Disable memory compression (Windows 10/11)
try {
    Disable-MMAgent -MemoryCompression
    Write-Host "Memory compression disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable memory compression" -ForegroundColor Red
}

# Set paging file to system managed on C: drive only
$cs = Get-WmiObject -Class Win32_ComputerSystem
if ($cs.AutomaticManagedPagefile) {
    $cs.AutomaticManagedPagefile = $false
    $cs.Put()
}

# ===================================================================
# SECURITY ENHANCEMENTS
# ===================================================================

Write-Host "Applying security enhancements..." -ForegroundColor Green

# Disable Guest account
try {
    Disable-LocalUser -Name "Guest"
    Write-Host "Guest account disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Guest account not found or already disabled" -ForegroundColor Yellow
}

# Enable UAC but reduce prompts for admins
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 2 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v PromptOnSecureDesktop /t REG_DWORD /d 0 /f

# Disable AutoRun for removable media
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v NoDriveTypeAutoRun /t REG_DWORD /d 255 /f

# Set strong password policy
net accounts /minpwlen:8 /maxpwage:90 /lockoutthreshold:5 /lockoutduration:30

# Disable SMB1 protocol (security vulnerability)
try {
    Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -NoRestart
    Write-Host "SMB1 protocol disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable SMB1 protocol" -ForegroundColor Red
}

# ===================================================================
# NETWORK AND INTERNET OPTIMIZATION
# ===================================================================

Write-Host "Optimizing network settings..." -ForegroundColor Green

# Disable Windows Update P2P sharing
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\DeliveryOptimization\Config" /v DODownloadMode /t REG_DWORD /d 0 /f

# Set DNS to Cloudflare (1.1.1.1) for better performance and privacy
try {
    $adapters = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
    foreach ($adapter in $adapters) {
        Set-DnsClientServerAddress -InterfaceAlias $adapter.Name -ServerAddresses "1.1.1.1", "1.0.0.1"
    }
    Write-Host "DNS set to Cloudflare (1.1.1.1, 1.0.0.1)" -ForegroundColor Green
} catch {
    Write-Host "Could not set DNS servers" -ForegroundColor Red
}

# Disable Teredo tunneling (can be security risk)
netsh interface teredo set state disabled

# Disable Windows Connect Now
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v EnableRegistrars /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v DisableUPnPRegistrar /t REG_DWORD /d 0 /f

# ===================================================================
# STARTUP AND SERVICES OPTIMIZATION
# ===================================================================

Write-Host "Optimizing startup and services..." -ForegroundColor Green

# List of services to disable for better performance
$servicesToDisable = @(
    "Fax",                    # Fax service
    "WMPNetworkSvc",         # Windows Media Player Network Sharing
    "TabletInputService",    # Tablet PC Input Service
    "WSearch",               # Windows Search (already handled above)
    "TrkWks",               # Distributed Link Tracking Client
    "WerSvc",               # Windows Error Reporting
    "DiagTrack",            # Connected User Experiences and Telemetry
    "dmwappushservice",     # WAP Push Message Routing Service
    "MapsBroker",           # Downloaded Maps Manager
    "lfsvc"                 # Geolocation Service
)

foreach ($service in $servicesToDisable) {
    try {
        $serviceObj = Get-Service -Name $service -ErrorAction SilentlyContinue
        if ($serviceObj) {
            Stop-Service -Name $service -Force -ErrorAction SilentlyContinue
            Set-Service -Name $service -StartupType Disabled
            Write-Host "Disabled service: $service" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "Could not disable service: $service" -ForegroundColor Red
    }
}

# ===================================================================
# REGISTRY CLEANUP AND OPTIMIZATION
# ===================================================================

Write-Host "Performing registry optimizations..." -ForegroundColor Green

# Disable Windows Tips and Tricks
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" /v SoftLandingEnabled /t REG_DWORD /d 0 /f
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" /v SystemPaneSuggestionsEnabled /t REG_DWORD /d 0 /f

# Disable consumer features (suggested apps)
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CloudContent" /v DisableWindowsConsumerFeatures /t REG_DWORD /d 1 /f

# Disable Windows Ink workspace
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsInkWorkspace" /v AllowWindowsInkWorkspace /t REG_DWORD /d 0 /f

# Disable People icon in taskbar
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\People" /v PeopleBand /t REG_DWORD /d 0 /f

# Disable Sticky Keys prompt
reg add "HKEY_CURRENT_USER\Control Panel\Accessibility\StickyKeys" /v Flags /t REG_SZ /d "506" /f

# Disable Filter Keys prompt  
reg add "HKEY_CURRENT_USER\Control Panel\Accessibility\Keyboard Response" /v Flags /t REG_SZ /d "122" /f

# Disable Toggle Keys prompt
reg add "HKEY_CURRENT_USER\Control Panel\Accessibility\ToggleKeys" /v Flags /t REG_SZ /d "58" /f

# ===================================================================
# ADDITIONAL SOFTWARE MANAGEMENT
# ===================================================================

Write-Host "Managing additional software..." -ForegroundColor Green

# List of built-in apps to remove (Windows 10/11 bloatware)
$appsToRemove = @(
    "Microsoft.3DBuilder",
    "Microsoft.BingFinance",
    "Microsoft.BingNews", 
    "Microsoft.BingSports",
    "Microsoft.BingWeather",
    "Microsoft.GetHelp",
    "Microsoft.Getstarted",
    "Microsoft.Messaging",
    "Microsoft.Microsoft3DViewer",
    "Microsoft.MicrosoftOfficeHub",
    "Microsoft.MicrosoftSolitaireCollection",
    "Microsoft.NetworkSpeedTest",
    "Microsoft.News",
    "Microsoft.Office.Lens",
    "Microsoft.Office.OneNote",
    "Microsoft.Office.Sway",
    "Microsoft.OneConnect",
    "Microsoft.People",
    "Microsoft.Print3D",
    "Microsoft.RemoteDesktop",
    "Microsoft.SkypeApp",
    "Microsoft.Wallet",
    "Microsoft.Whiteboard",
    "Microsoft.WindowsAlarms",
    "Microsoft.WindowsCamera",
    "microsoft.windowscommunicationsapps",
    "Microsoft.WindowsFeedbackHub",
    "Microsoft.WindowsMaps",
    "Microsoft.WindowsSoundRecorder",
    "Microsoft.Xbox.TCUI",
    "Microsoft.XboxApp",
    "Microsoft.XboxGameOverlay",
    "Microsoft.XboxGamingOverlay",
    "Microsoft.XboxIdentityProvider",
    "Microsoft.XboxSpeechToTextOverlay",
    "Microsoft.ZuneMusic",
    "Microsoft.ZuneVideo"
)

foreach ($app in $appsToRemove) {
    try {
        Get-AppxPackage -Name $app -AllUsers | Remove-AppxPackage -ErrorAction SilentlyContinue
        Get-AppxProvisionedPackage -Online | Where-Object DisplayName -like $app | Remove-AppxProvisionedPackage -Online -ErrorAction SilentlyContinue
        Write-Host "Removed app: $app" -ForegroundColor Yellow
    } catch {
        # Silently continue if app is not found
    }
}

# ===================================================================
# DISK CLEANUP AND MAINTENANCE
# ===================================================================

Write-Host "Performing disk cleanup..." -ForegroundColor Green

# Clean temporary files
Remove-Item -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "$env:LOCALAPPDATA\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue

# Clear Windows Update cache
try {
    Stop-Service wuauserv -Force
    Remove-Item -Path "$env:WINDIR\SoftwareDistribution\Download\*" -Recurse -Force -ErrorAction SilentlyContinue
    Start-Service wuauserv
    Write-Host "Windows Update cache cleared" -ForegroundColor Yellow
} catch {
    Write-Host "Could not clear Windows Update cache" -ForegroundColor Red
}

# Enable Storage Sense (automatic cleanup)
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy" /v 01 /t REG_DWORD /d 1 /f

# ===================================================================
# CONFIGURATION RESTORE SYSTEM
# ===================================================================

function Get-CurrentlyInstalledApplications {
    Write-Host "Scanning currently installed applications..." -ForegroundColor Cyan
    
    $currentApps = @{}
    
    # Get currently installed software using the same methods as discovery
    try {
        # Registry 64-bit
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg64) {
            $currentApps[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
        
        # Registry 32-bit
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $currentApps.ContainsKey($app.DisplayName)) {
                $currentApps[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
        
        # Store Apps
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            if (-not $currentApps.ContainsKey($app.Name)) {
                $currentApps[$app.Name] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
        
        Write-Host "Found $($currentApps.Count) currently installed applications" -ForegroundColor Green
        return $currentApps
        
    } catch {
        Write-Host "Error scanning installed applications: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Find-AvailableBackups {
    param([string]$BackupBasePath)
    
    Write-Host "Searching for available backups in: $BackupBasePath" -ForegroundColor Cyan
    
    if (!(Test-Path $BackupBasePath)) {
        Write-Host "Backup base path does not exist: $BackupBasePath" -ForegroundColor Red
        return @{}
    }
    
    $availableBackups = @{}
    
    try {
        # Find all backup sessions (timestamp directories)
        $backupSessions = Get-ChildItem $BackupBasePath -Directory | 
            Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "`n💾 BACKUP/RESTORE INFORMATION:" -ForegroundColor Yellow
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    if ($Restore) {
        Write-Host "• Interactive restore: Current configs backed up before restore" -ForegroundColor White
        Write-Host "• Restore logs available in backup base path" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White
Write-Host "Restore configurations: .\script.ps1 -Mode home -Restore" -ForegroundColor White
Write-Host "Restore with custom path: .\script.ps1 -Mode home -Restore -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    if (-not $Restore) {
        Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    }
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
    if ($Restore) {
        Write-Host "Before-restore backups: BackupBasePath\beforeRestoreBackup_YYYY-MM-DD_HH-MM-SS\[AppName]" -ForegroundColor Gray
    }
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan } |
            Sort-Object Name -Descending
        
        foreach ($session in $backupSessions) {
            $sessionPath = $session.FullName
            $sessionName = $session.Name
            
            # Check for StandardSoftwareBackup
            $standardBackupPath = Join-Path $sessionPath "StandardSoftwareBackup\AppData"
            if (Test-Path $standardBackupPath) {
                $standardApps = Get-ChildItem $standardBackupPath -Directory
                foreach ($app in $standardApps) {
                    $appName = $app.Name
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Standard"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
            
            # Check for ComprehensiveSoftwareBackup
            $comprehensiveBackupPath = Join-Path $sessionPath "ComprehensiveSoftwareBackup\Applications"
            if (Test-Path $comprehensiveBackupPath) {
                $comprehensiveApps = Get-ChildItem $comprehensiveBackupPath -Directory
                foreach ($app in $comprehensiveApps) {
                    $appName = $app.Name -replace '_', ' '  # Restore original name format
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Comprehensive"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
        }
        
        Write-Host "Found backups for $($availableBackups.Count) applications across $($backupSessions.Count) sessions" -ForegroundColor Green
        return $availableBackups
        
    } catch {
        Write-Host "Error searching for backups: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Backup-CurrentConfiguration {
    param(
        [string]$AppName,
        [string]$RestoreBackupPath,
        [string]$BackupBasePath
    )
    
    try {
        # Create beforeRestore backup directory
        $beforeRestoreTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
        $beforeRestorePath = "$BackupBasePath\beforeRestoreBackup_$beforeRestoreTimestamp\$($AppName -replace '[^\w\s-]', '_')"
        New-Item -Path $beforeRestorePath -ItemType Directory -Force | Out-Null
        
        # Get current configuration paths for the application
        $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
        
        $backupSuccess = $false
        
        # Backup current configuration files
        foreach ($configPath in $paths.ConfigPaths) {
            try {
                if (Test-Path $configPath) {
                    $destinationPath = Join-Path $beforeRestorePath (Split-Path $configPath -Leaf)
                    if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                        Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force
                    } else {
                        Copy-Item -Path $configPath -Destination $destinationPath -Force
                    }
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current: $(Split-Path $configPath -Leaf)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup: $configPath" -ForegroundColor Yellow
            }
        }
        
        # Backup current registry keys
        foreach ($regPath in $paths.RegistryPaths) {
            try {
                $regFileName = "$beforeRestorePath\$($AppName -replace '[^\w\s-]', '_')_current_registry.reg"
                reg export "$regPath" "$regFileName" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current registry: $regPath" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup registry: $regPath" -ForegroundColor Yellow
            }
        }
        
        if ($backupSuccess) {
            # Create metadata file
            $metadata = @{
                AppName = $AppName
                BackupDate = Get-Date
                RestoreSource = $RestoreBackupPath
                Purpose = "BeforeRestore"
            }
            $metadata | ConvertTo-Json | Out-File "$beforeRestorePath\backup_metadata.json" -Encoding UTF8
            
            Write-Host "✅ Current configuration backed up to: $beforeRestorePath" -ForegroundColor Green
            return $beforeRestorePath
        } else {
            Write-Host "⚠ No current configuration found to backup for: $AppName" -ForegroundColor Yellow
            return $null
        }
        
    } catch {
        Write-Host "❌ Failed to backup current configuration: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Restore-ApplicationConfiguration {
    param(
        [string]$AppName,
        [string]$BackupPath,
        [string]$BackupBasePath
    )
    
    Write-Host "`n🔄 RESTORING CONFIGURATION FOR: $AppName" -ForegroundColor Cyan
    Write-Host "From backup: $BackupPath" -ForegroundColor Gray
    
    try {
        # First, backup current configuration
        Write-Host "`n📦 Creating backup of current configuration..." -ForegroundColor Yellow
        $beforeRestoreBackup = Backup-CurrentConfiguration -AppName $AppName -RestoreBackupPath $BackupPath -BackupBasePath $BackupBasePath
        
        $restoreSuccess = $false
        $restoredItems = @()
        
        # Restore configuration files
        Write-Host "`n📂 Restoring configuration files..." -ForegroundColor Yellow
        $configFiles = Get-ChildItem $BackupPath -File | Where-Object { $_.Name -notlike "*.reg" -and $_.Name -ne "backup_metadata.json" }
        
        foreach ($file in $configFiles) {
            try {
                # Try to determine target path based on file name and application
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetFile = Join-Path $parentDir $file.Name
                        Copy-Item -Path $file.FullName -Destination $targetFile -Force
                        Write-Host "✓ Restored: $($file.Name) → $targetFile" -ForegroundColor Green
                        $restoredItems += $targetFile
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for: $($file.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore: $($file.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore configuration directories
        $configDirs = Get-ChildItem $BackupPath -Directory
        foreach ($dir in $configDirs) {
            try {
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetDir = Join-Path $parentDir $dir.Name
                        Copy-Item -Path $dir.FullName -Destination $targetDir -Recurse -Force
                        Write-Host "✓ Restored directory: $($dir.Name) → $targetDir" -ForegroundColor Green
                        $restoredItems += $targetDir
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for directory: $($dir.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore directory: $($dir.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore registry entries
        Write-Host "`n🔧 Restoring registry entries..." -ForegroundColor Yellow
        $regFiles = Get-ChildItem $BackupPath -Filter "*.reg"
        
        foreach ($regFile in $regFiles) {
            try {
                Write-Host "Importing registry: $($regFile.Name)" -ForegroundColor Cyan
                reg import "$($regFile.FullName)" /reg:64
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Registry imported: $($regFile.Name)" -ForegroundColor Green
                    $restoredItems += $regFile.FullName
                    $restoreSuccess = $true
                } else {
                    Write-Host "✗ Registry import failed: $($regFile.Name)" -ForegroundColor Red
                }
            } catch {
                Write-Host "✗ Registry import error: $($regFile.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Create restore log
        if ($restoreSuccess) {
            $restoreLog = @{
                AppName = $AppName
                RestoreDate = Get-Date
                SourceBackup = $BackupPath
                BeforeRestoreBackup = $beforeRestoreBackup
                RestoredItems = $restoredItems
                Status = "Success"
            }
            
            $logPath = "$BackupBasePath\restore_log_$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss').json"
            $restoreLog | ConvertTo-Json -Depth 3 | Out-File $logPath -Encoding UTF8
            
            Write-Host "`n✅ RESTORE COMPLETED SUCCESSFULLY" -ForegroundColor Green
            Write-Host "Restored items: $($restoredItems.Count)" -ForegroundColor White
            Write-Host "Restore log: $logPath" -ForegroundColor White
            if ($beforeRestoreBackup) {
                Write-Host "Current config backed up to: $beforeRestoreBackup" -ForegroundColor White
            }
            
            return $true
        } else {
            Write-Host "`n❌ RESTORE FAILED - No items were successfully restored" -ForegroundColor Red
            return $false
        }
        
    } catch {
        Write-Host "`n❌ RESTORE ERROR: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

function Start-ConfigurationRestore {
    param([string]$BackupBasePath)
    
    Write-Host "`n🔄 CONFIGURATION RESTORE MODE" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    
    # Get currently installed applications
    $currentApps = Get-CurrentlyInstalledApplications
    if ($currentApps.Count -eq 0) {
        Write-Host "No installed applications found. Cannot proceed with restore." -ForegroundColor Red
        return
    }
    
    # Find available backups
    $availableBackups = Find-AvailableBackups -BackupBasePath $BackupBasePath
    if ($availableBackups.Count -eq 0) {
        Write-Host "No configuration backups found in: $BackupBasePath" -ForegroundColor Red
        return
    }
    
    # Find applications that are both installed and have backups
    $restorableApps = @{}
    foreach ($appName in $availableBackups.Keys) {
        # Try to match app names (exact match or partial match)
        $matchingApp = $null
        foreach ($installedApp in $currentApps.Keys) {
            if ($installedApp -eq $appName -or 
                $installedApp -like "*$appName*" -or 
                $appName -like "*$installedApp*") {
                $matchingApp = $installedApp
                break
            }
        }
        
        if ($matchingApp) {
            $restorableApps[$appName] = @{
                InstalledName = $matchingApp
                Backups = $availableBackups[$appName]
            }
        }
    }
    
    if ($restorableApps.Count -eq 0) {
        Write-Host "No restorable applications found." -ForegroundColor Yellow
        Write-Host "This means no installed applications have available configuration backups." -ForegroundColor Yellow
        return
    }
    
    Write-Host "`n📋 RESTORABLE APPLICATIONS:" -ForegroundColor Green
    Write-Host "Found $($restorableApps.Count) applications with available backups" -ForegroundColor White
    
    # Display restorable applications
    $appIndex = 1
    $appList = @()
    foreach ($app in $restorableApps.GetEnumerator()) {
        $appList += $app
        Write-Host "$appIndex. $($app.Key) ($($app.Value.Backups.Count) backup(s) available)" -ForegroundColor Cyan
        $appIndex++
    }
    
    # Application selection loop
    do {
        Write-Host "`n🎯 SELECT APPLICATION TO RESTORE:" -ForegroundColor Yellow
        Write-Host "Enter application number (1-$($appList.Count)) or 'q' to quit: " -NoNewline
        $selection = Read-Host
        
        if ($selection -eq 'q' -or $selection -eq 'Q') {
            Write-Host "Restore cancelled by user." -ForegroundColor Yellow
            return
        }
        
        if ($selection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$selection -ge 1 -and [int]$selection -le $appList.Count) {
            $selectedApp = $appList[[int]$selection - 1]
            $appName = $selectedApp.Key
            $appBackups = $selectedApp.Value.Backups
            
            Write-Host "`n📦 AVAILABLE BACKUPS FOR: $appName" -ForegroundColor Cyan
            
            # Display available backups
            $backupIndex = 1
            foreach ($backup in $appBackups) {
                Write-Host "$backupIndex. Session: $($backup.Session) | Type: $($backup.Type) | Date: $($backup.BackupDate)" -ForegroundColor White
                $backupIndex++
            }
            
            # Backup selection
            Write-Host "`nSelect backup number (1-$($appBackups.Count)) or 'b' to go back: " -NoNewline
            $backupSelection = Read-Host
            
            if ($backupSelection -eq 'b' -or $backupSelection -eq 'B') {
                continue  # Go back to app selection
            }
            
            if ($backupSelection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$backupSelection -ge 1 -and [int]$backupSelection -le $appBackups.Count) {
                $selectedBackup = $appBackups[[int]$backupSelection - 1]
                
                Write-Host "`n⚠️  CONFIRMATION REQUIRED" -ForegroundColor Yellow
                Write-Host "You are about to restore configuration for: $appName" -ForegroundColor White
                Write-Host "From backup: $($selectedBackup.Session) ($($selectedBackup.Type))" -ForegroundColor White
                Write-Host "Current configuration will be backed up before restore." -ForegroundColor White
                Write-Host "`nProceed with restore? (y/n): " -NoNewline
                $confirm = Read-Host
                
                if ($confirm -eq 'y' -or $confirm -eq 'Y' -or $confirm -eq 'yes') {
                    $restoreResult = Restore-ApplicationConfiguration -AppName $appName -BackupPath $selectedBackup.Path -BackupBasePath $BackupBasePath
                    
                    if ($restoreResult) {
                        Write-Host "`n🎉 Configuration restored successfully!" -ForegroundColor Green
                        Write-Host "You may need to restart the application to see changes." -ForegroundColor Yellow
                    } else {
                        Write-Host "`n💥 Configuration restore failed!" -ForegroundColor Red
                    }
                    
                    Write-Host "`nRestore another application? (y/n): " -NoNewline
                    $continueRestore = Read-Host
                    if ($continueRestore -ne 'y' -and $continueRestore -ne 'Y' -and $continueRestore -ne 'yes') {
                        break
                    }
                } else {
                    Write-Host "Restore cancelled." -ForegroundColor Yellow
                }
            } else {
                Write-Host "Invalid backup selection." -ForegroundColor Red
            }
        } else {
            Write-Host "Invalid application selection." -ForegroundColor Red
        }
    } while ($true)
    
    Write-Host "`n✅ RESTORE SESSION COMPLETED" -ForegroundColor Green
}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$selection -ge 1 -and [int]$selection -le $systemBackups.Count) {
        $selectedBackup = $systemBackups[[int]$selection - 1]
        
        Write-Host "`n⚠️  ROLLBACK CONFIRMATION" -ForegroundColor Yellow
        Write-Host "You are about to rollback system settings to backup: $($selectedBackup.Name)" -ForegroundColor White
        Write-Host "This will reverse all changes made by this script." -ForegroundColor White
        Write-Host "Current system state will be backed up before rollback." -ForegroundColor White
        Write-Host "`nProceed with rollback? (y/n): " -NoNewline
        $confirm = Read-Host
        
        if ($confirm -eq 'y' -or $confirm -eq 'Y' -or $confirm -eq 'yes') {
            # Create backup of current state before rollback
            Write-DetailedLog -Message "Creating backup before rollback..." -Level "BACKUP"
            $preRollbackBackup = New-SystemBackup -BackupReason "Pre-Rollback-$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss')"
            
            # Execute rollback script
            $rollbackScriptPath = Join-Path $selectedBackup.FullName "ROLLBACK_SYSTEM.ps1"
            if (Test-Path $rollbackScriptPath) {
                try {
                    Write-DetailedLog -Message "Executing rollback script: $rollbackScriptPath" -Level "RESTORE"
                    & PowerShell.exe -ExecutionPolicy Bypass -File $rollbackScriptPath
                    Write-DetailedLog -Message "Rollback completed successfully" -Level "SUCCESS"
                    return $true
                } catch {
                    Write-DetailedLog -Message "Rollback failed: $($_.Exception.Message)" -Level "ERROR"
                    return $false
                }
            } else {
                Write-DetailedLog -Message "Rollback script not found: $rollbackScriptPath" -Level "ERROR"
                return $false
            }
        } else {
            Write-DetailedLog -Message "Rollback cancelled by user" -Level "INFO"
            return $false
        }
    } else {
        Write-DetailedLog -Message "Invalid selection for rollback" -Level "ERROR"
        return $false
    }
}

# ===================================================================
# BACKUP CONFIGURATION CONSTANTS
# ===================================================================

# Create standardized backup path structure
$BackupTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
$StandardBackupPath = "$BackupBasePath\$BackupTimestamp"

# Initialize logging
Start-OperationLog -OperationName "WindowsConfigurationScript" -Parameters @{
    Mode = $Mode
    BackupSoftware = $BackupSoftware
    BackupAllInstalledSoftware = $BackupAllInstalledSoftware
    Restore = $Restore
    Rollback = $Rollback
    BackupBasePath = $BackupBasePath
}

Write-Host "==================================================================" -ForegroundColor Cyan
Write-Host "Windows Configuration Script - $($Mode.ToUpper()) Mode" -ForegroundColor Green
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Backup Base Path: $BackupBasePath" -ForegroundColor Yellow
    Write-Host "Session Backup Path: $StandardBackupPath" -ForegroundColor Yellow
}
Write-Host "Log File: $LogPath" -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan

# ===================================================================
# POWER MANAGEMENT
# ===================================================================

# Set active power plan to High Performance
Write-Host "Configuring power management..." -ForegroundColor Green
powercfg.exe -SETACTIVE 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c

# Disable Fast Startup (improves boot reliability)
REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f

# ===================================================================
# REMOTE DESKTOP CONFIGURATION
# ===================================================================

Write-Host "Enabling Remote Desktop..." -ForegroundColor Green

# Enable Remote Desktop connections (Registry method)
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

# Enable Remote Desktop connections (PowerShell method)
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0

# Enable Remote Desktop firewall rules
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

# Alternative firewall configuration (commented out)
# netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
# netsh advfirewall firewall add rule name="allow RemoteDesktop" dir=in protocol=TCP localport=3389 action=allow

# ===================================================================
# NETWORK CONFIGURATION
# ===================================================================

# Enable ICMP ping responses for local subnet
Write-Host "Configuring network settings..." -ForegroundColor Green
New-NetFirewallRule -DisplayName "!!! ICMP PING" -Direction Inbound -Protocol ICMPv4 -RemoteAddress LocalSubnet -Action Allow

# Disable IPv6 on all network adapters (commented out)
# Disable-NetAdapterBinding -Name * -ComponentID ms_tcpip6

# ===================================================================
# USER INTERFACE CUSTOMIZATIONS
# ===================================================================

Write-Host "Customizing user interface..." -ForegroundColor Green

# Enable classic context menu in Windows 11
reg add "HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" /f /ve

# Disable Windows Quiet Hours/Focus Assist
reg add "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\QuietHours" /v Enable /t REG_DWORD /d 0 /f

# ===================================================================
# TASKBAR CUSTOMIZATION
# ===================================================================

Write-Host "Customizing taskbar..." -ForegroundColor Green

# Function to unpin applications from taskbar
function Unpin-FromTaskbar {
    param([string]$AppName)
    
    $app = (New-Object -Com Shell.Application).NameSpace('shell:::{4234d49b-0245-4df3-b780-3893943456e1}').Items() | Where-Object {$_.Name -eq $AppName}
    if ($app) {
        $unpinVerb = $app.Verbs() | Where-Object {$_.Name.replace('&','') -match 'Unpin from taskbar'}
        if ($unpinVerb) {
            $unpinVerb.DoIt()
            Write-Host "Unpinned $AppName from taskbar" -ForegroundColor Yellow
        }
    }
}

# Unpin default applications from taskbar
Unpin-FromTaskbar "Microsoft Edge"
Unpin-FromTaskbar "Microsoft Store"
Unpin-FromTaskbar "Mail"

# Hide search box from taskbar
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Search" /v SearchboxTaskbarMode /t REG_DWORD /d 0 /f

# Hide Task View button from taskbar
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v ShowTaskViewButton /t REG_DWORD /d 0 /f

# Hide Cortana button from taskbar
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v ShowCortanaButton /t REG_DWORD /d 0 /f

# Hide Teams Chat icon from taskbar (Windows 11)
REG ADD "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /f /v TaskbarMn /t REG_DWORD /d 0

# Disable multitasking view
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MultiTaskingView\AllUpView" /v Enabled /t REG_DWORD /d 0 /f

# Disable auto-tray for system icons
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer" /v EnableAutoTray /t REG_DWORD /d 0 /f

# ===================================================================
# FILE EXPLORER CONFIGURATION
# ===================================================================

Write-Host "Configuring File Explorer..." -ForegroundColor Green

# Set File Explorer to open to "This PC" instead of Quick Access
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v LaunchTo /t REG_DWORD /d 1 /f

# ===================================================================
# CORTANA AND SEARCH CONFIGURATION
# ===================================================================

Write-Host "Disabling Cortana..." -ForegroundColor Green

# Disable Cortana
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search" /v AllowCortana /t REG_DWORD /d 0 /f

# Disable Cortana above lock screen
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search" /v AllowCortanaAboveLock /t REG_DWORD /d 0 /f

# Disable search location usage
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search" /v AllowSearchToUseLocation /t REG_DWORD /d 0 /f

# Disable Windows Feeds (News and Interests)
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Feeds" /v EnableFeeds /t REG_DWORD /d 0 /f

# ===================================================================
# USER ACCOUNT CONFIGURATION
# ===================================================================

Write-Host "Configuring user accounts..." -ForegroundColor Green

# Hide specific user accounts from login screen
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v "it dept" /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v "jack" /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v "jacek_brychcy_p" /t REG_DWORD /d 0 /f

# Set IT DEPT user password to never expire
try {
    Set-LocalUser -Name "IT DEPT" -PasswordNeverExpires $true
    Write-Host "IT DEPT password set to never expire" -ForegroundColor Yellow
} catch {
    Write-Host "Could not configure IT DEPT user - user may not exist" -ForegroundColor Red
}

# ===================================================================
# OFFICE CONFIGURATION
# ===================================================================

Write-Host "Configuring Office applications..." -ForegroundColor Green

# Disable Outlook connection check message
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\16.0\Outlook\Options\General" /v "EnableImprovedCaptivePortalExperience" /t REG_DWORD /d 0 /f

# ===================================================================
# SYSTEM OPTIMIZATION
# ===================================================================

Write-Host "Optimizing system performance..." -ForegroundColor Green

# Disable indexing on all volumes
Get-WmiObject -Class win32_volume | Set-WmiInstance -Arguments @{IndexingEnabled=$false}

# Remove Microsoft Teams (if installed)
Write-Host "Removing Microsoft Teams..." -ForegroundColor Yellow
Get-AppxPackage *Teams* | Remove-AppxPackage -AllUsers -ErrorAction SilentlyContinue
Get-AppxProvisionedPackage -online | Where-Object {$_.PackageName -like "*Teams*"} | Remove-AppxProvisionedPackage -online -ErrorAction SilentlyContinue

# Uninstall Windows Web Experience Pack (Windows 11)
try {
    winget uninstall "windows web experience pack" --force --accept-source-agreements
} catch {
    Write-Host "Windows Web Experience Pack not found or already removed" -ForegroundColor Yellow
}

# ===================================================================
# SOFTWARE INSTALLATION AND CONFIGURATION
# ===================================================================

Write-Host "Installing PowerShell modules and software..." -ForegroundColor Green

# Install essential PowerShell modules
try {
    Install-Module -Name PSReadLine, PSWindowsUpdate, Carbon, ImportExcel -Force -AllowClobber -Scope AllUsers
    Write-Host "PowerShell modules installed successfully" -ForegroundColor Green
} catch {
    Write-Host "Error installing PowerShell modules: $($_.Exception.Message)" -ForegroundColor Red
}

# Ensure Winget is available and updated
try {
    $wingetVersion = winget --version
    Write-Host "Winget is available (version: $wingetVersion)" -ForegroundColor Green
} catch {
    Write-Host "Winget not available, will use Chocolatey as fallback" -ForegroundColor Yellow
}

# Check if Chocolatey is installed, if not install it
if (!(Get-Command choco.exe -ErrorAction SilentlyContinue)) {
    Write-Host "Installing Chocolatey package manager..." -ForegroundColor Yellow
    try {
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
        $env:PATH = [Environment]::GetEnvironmentVariable("PATH","Machine") + ";" + [Environment]::GetEnvironmentVariable("PATH","User")
        Write-Host "Chocolatey installed successfully" -ForegroundColor Green
    } catch {
        Write-Host "Failed to install Chocolatey: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to install software with Winget first, fallback to Chocolatey
function Install-Software {
    param(
        [string]$SoftwareName,
        [string]$WingetID = "",
        [string]$ChocoPackage = "",
        [string]$ChocoParams = "",
        [bool]$Silent = $false
    )
    
    $installed = $false
    
    # Try Winget first if ID is provided
    if ($WingetID -ne "" -and (Get-Command winget -ErrorAction SilentlyContinue)) {
        try {
            Write-Host "Attempting to install $SoftwareName via Winget..." -ForegroundColor Cyan
            winget install --id=$WingetID --accept-source-agreements --accept-package-agreements --silent
            if ($LASTEXITCODE -eq 0) {
                Write-Host "$SoftwareName installed successfully via Winget" -ForegroundColor Green
                $installed = $true
            } else {
                Write-Host "Winget installation failed for $SoftwareName (Exit code: $LASTEXITCODE)" -ForegroundColor Yellow
            }
        } catch {
            Write-Host "Winget installation failed for $SoftwareName : $($_.Exception.Message)" -ForegroundColor Yellow
        }
    }
    
    # Fallback to Chocolatey if Winget failed or not available
    if (-not $installed -and $ChocoPackage -ne "") {
        try {
            Write-Host "Installing $SoftwareName via Chocolatey..." -ForegroundColor Cyan
            if ($ChocoParams -ne "") {
                choco install $ChocoPackage -y $ChocoParams
            } else {
                choco install $ChocoPackage -y
            }
            if ($LASTEXITCODE -eq 0) {
                Write-Host "$SoftwareName installed successfully via Chocolatey" -ForegroundColor Green
                $installed = $true
            } else {
                Write-Host "Chocolatey installation failed for $SoftwareName (Exit code: $LASTEXITCODE)" -ForegroundColor Red
            }
        } catch {
            Write-Host "Chocolatey installation failed for $SoftwareName : $($_.Exception.Message)" -ForegroundColor Red
        }
    }
    
    if (-not $installed) {
        Write-Host "Failed to install $SoftwareName via both Winget and Chocolatey" -ForegroundColor Red
    }
    
    return $installed
}

# Function to prompt user for software installation
function Ask-InstallSoftware {
    param(
        [string]$SoftwareName,
        [string]$WingetID = "",
        [string]$ChocoPackage = "",
        [string]$Description = "",
        [string]$ChocoParams = ""
    )
    
    $choice = Read-Host "Do you want to install $SoftwareName ($Description)? (y/n)"
    if ($choice -eq 'y' -or $choice -eq 'Y' -or $choice -eq 'yes') {
        Install-Software -SoftwareName $SoftwareName -WingetID $WingetID -ChocoPackage $ChocoPackage -ChocoParams $ChocoParams
    } else {
        Write-Host "Skipping $SoftwareName installation" -ForegroundColor Yellow
    }
}

# Software installation based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- HOME MODE SOFTWARE SELECTION ---" -ForegroundColor Cyan
    Write-Host "Select software to install. Each category will be presented separately." -ForegroundColor Yellow
    
    # ===================================================================
    # BASIC APPLICATIONS
    # ===================================================================
    Write-Host "`n=== BASIC APPLICATIONS ===" -ForegroundColor Magenta
    
    # Bitwarden
    Ask-InstallSoftware -SoftwareName "Bitwarden" -WingetID "Bitwarden.Bitwarden" -ChocoPackage "bitwarden" -Description "Password manager"
    
    # Office 365 Enterprise
    Ask-InstallSoftware -SoftwareName "Office 365 Enterprise" -WingetID "Microsoft.Office" -ChocoPackage "office365business" -Description "Microsoft Office suite"
    
    # Visual Studio Code
    Ask-InstallSoftware -SoftwareName "Visual Studio Code" -WingetID "Microsoft.VisualStudioCode" -ChocoPackage "vscode" -Description "Code editor and IDE" -ChocoParams "--params '/NoDesktopIcon /NoQuicklaunchIcon'"
    
    # ===================================================================
    # WINDOWS ADMINISTRATION TOOLS
    # ===================================================================
    Write-Host "`n=== WINDOWS ADMINISTRATION TOOLS ===" -ForegroundColor Magenta
    
    # Windows Terminal
    Ask-InstallSoftware -SoftwareName "Windows Terminal" -WingetID "Microsoft.WindowsTerminal" -ChocoPackage "microsoft-windows-terminal" -Description "Modern terminal application"
    
    # PowerToys
    Ask-InstallSoftware -SoftwareName "PowerToys" -WingetID "Microsoft.PowerToys" -ChocoPackage "powertoys" -Description "Windows system utilities"
    
    # Sysinternals Suite
    Ask-InstallSoftware -SoftwareName "Sysinternals Suite" -WingetID "Microsoft.Sysinternals" -ChocoPackage "sysinternals" -Description "Windows diagnostic tools"
    
    # Process Monitor
    Ask-InstallSoftware -SoftwareName "Process Monitor" -WingetID "Microsoft.Sysinternals.ProcessMonitor" -ChocoPackage "procmon" -Description "Real-time file system and process monitoring"
    
    # Process Explorer
    Ask-InstallSoftware -SoftwareName "Process Explorer" -WingetID "Microsoft.Sysinternals.ProcessExplorer" -ChocoPackage "procexp" -Description "Advanced Task Manager replacement"
    
    # CMTrace
    Ask-InstallSoftware -SoftwareName "CMTrace" -WingetID "" -ChocoPackage "cmtrace" -Description "Microsoft log viewer tool"
    
    # Dell Command Update
    Ask-InstallSoftware -SoftwareName "Dell Command Update" -WingetID "Dell.CommandUpdate" -ChocoPackage "DellCommandUpdate" -Description "Dell driver and BIOS updates"
    
    # ===================================================================
    # NETWORK & SECURITY TOOLS
    # ===================================================================
    Write-Host "`n=== NETWORK & SECURITY TOOLS ===" -ForegroundColor Magenta
    
    # Wireshark
    Ask-InstallSoftware -SoftwareName "Wireshark" -WingetID "WiresharkFoundation.Wireshark" -ChocoPackage "wireshark" -Description "Network protocol analyzer"
    
    # PuTTY
    Ask-InstallSoftware -SoftwareName "PuTTY" -WingetID "PuTTY.PuTTY" -ChocoPackage "putty" -Description "SSH and telnet client"
    
    # WinSCP
    Ask-InstallSoftware -SoftwareName "WinSCP" -WingetID "WinSCP.WinSCP" -ChocoPackage "winscp" -Description "SFTP and SCP client"
    
    # OpenVPN Connect
    Ask-InstallSoftware -SoftwareName "OpenVPN Connect" -WingetID "OpenVPNTechnologies.OpenVPNConnect" -ChocoPackage "openvpn-connect" -Description "VPN client"
    
    # Nmap
    Ask-InstallSoftware -SoftwareName "Nmap" -WingetID "Insecure.Nmap" -ChocoPackage "nmap" -Description "Network discovery and security auditing"
    
    # ===================================================================
    # VERSION CONTROL & GIT
    # ===================================================================
    Write-Host "`n=== VERSION CONTROL & GIT ===" -ForegroundColor Magenta
    
    # Git for Windows
    Ask-InstallSoftware -SoftwareName "Git for Windows" -WingetID "Git.Git" -ChocoPackage "git" -Description "Distributed version control system"
    
    # GitHub Desktop
    Ask-InstallSoftware -SoftwareName "GitHub Desktop" -WingetID "GitHub.GitHubDesktop" -ChocoPackage "github-desktop" -Description "GUI for GitHub"
    
    # Sourcetree
    Ask-InstallSoftware -SoftwareName "Sourcetree" -WingetID "Atlassian.Sourcetree" -ChocoPackage "sourcetree" -Description "Git GUI client"
    
    # ===================================================================
    # DEVELOPMENT TOOLS
    # ===================================================================
    Write-Host "`n=== DEVELOPMENT TOOLS ===" -ForegroundColor Magenta
    
    # Notepad++
    Ask-InstallSoftware -SoftwareName "Notepad++" -WingetID "Notepad++.Notepad++" -ChocoPackage "notepadplusplus" -Description "Advanced text editor"
    
    # JetBrains Toolbox
    Ask-InstallSoftware -SoftwareName "JetBrains Toolbox" -WingetID "JetBrains.Toolbox" -ChocoPackage "jetbrainstoolbox" -Description "JetBrains IDE manager"
    
    # IntelliJ IDEA Community
    Ask-InstallSoftware -SoftwareName "IntelliJ IDEA Community" -WingetID "JetBrains.IntelliJIDEA.Community" -ChocoPackage "intellijidea-community" -Description "Java IDE"
    
    # PyCharm Community
    Ask-InstallSoftware -SoftwareName "PyCharm Community" -WingetID "JetBrains.PyCharm.Community" -ChocoPackage "pycharm-community" -Description "Python IDE"
    
    # ===================================================================
    # PYTHON ECOSYSTEM
    # ===================================================================
    Write-Host "`n=== PYTHON ECOSYSTEM ===" -ForegroundColor Magenta
    
    # Python
    Ask-InstallSoftware -SoftwareName "Python" -WingetID "Python.Python.3.12" -ChocoPackage "python" -Description "Python programming language"
    
    # Miniconda
    Ask-InstallSoftware -SoftwareName "Miniconda" -WingetID "Anaconda.Miniconda3" -ChocoPackage "miniconda3" -Description "Minimal conda installer"
    
    # Anaconda
    Ask-InstallSoftware -SoftwareName "Anaconda" -WingetID "Anaconda.Anaconda3" -ChocoPackage "anaconda3" -Description "Data science platform"
    
    # ===================================================================
    # AI/LLM DEVELOPMENT
    # ===================================================================
    Write-Host "`n=== AI/LLM DEVELOPMENT ===" -ForegroundColor Magenta
    
    # Ollama
    Ask-InstallSoftware -SoftwareName "Ollama" -WingetID "Ollama.Ollama" -ChocoPackage "ollama" -Description "Run large language models locally"
    
    # LM Studio
    Ask-InstallSoftware -SoftwareName "LM Studio" -WingetID "LMStudio.LMStudio" -ChocoPackage "lmstudio" -Description "GUI for local LLMs"
    
    # CUDA Toolkit (for NVIDIA GPUs)
    Ask-InstallSoftware -SoftwareName "CUDA Toolkit" -WingetID "Nvidia.CUDA" -ChocoPackage "cuda" -Description "NVIDIA GPU computing toolkit"
    
    # ===================================================================
    # CONTAINER & CLOUD TOOLS
    # ===================================================================
    Write-Host "`n=== CONTAINER & CLOUD TOOLS ===" -ForegroundColor Magenta
    
    # Docker Desktop
    Ask-InstallSoftware -SoftwareName "Docker Desktop" -WingetID "Docker.DockerDesktop" -ChocoPackage "docker-desktop" -Description "Containerization platform"
    
    # Kubernetes CLI
    Ask-InstallSoftware -SoftwareName "Kubectl" -WingetID "Kubernetes.kubectl" -ChocoPackage "kubernetes-cli" -Description "Kubernetes command-line tool"
    
    # Lens
    Ask-InstallSoftware -SoftwareName "Lens" -WingetID "MiranovaTeam.Lens" -ChocoPackage "lens" -Description "Kubernetes IDE"
    
    # Azure CLI
    Ask-InstallSoftware -SoftwareName "Azure CLI" -WingetID "Microsoft.AzureCLI" -ChocoPackage "azure-cli" -Description "Azure command-line interface"
    
    # AWS CLI
    Ask-InstallSoftware -SoftwareName "AWS CLI" -WingetID "Amazon.AWSCLI" -ChocoPackage "awscli" -Description "Amazon Web Services CLI"
    
    # Google Cloud SDK
    Ask-InstallSoftware -SoftwareName "Google Cloud SDK" -WingetID "Google.CloudSDK" -ChocoPackage "gcloudsdk" -Description "Google Cloud command-line tools"
    
    # Terraform
    Ask-InstallSoftware -SoftwareName "Terraform" -WingetID "Hashicorp.Terraform" -ChocoPackage "terraform" -Description "Infrastructure as Code tool"
    
    # ===================================================================
    # COMMUNICATION & MEDIA
    # ===================================================================
    Write-Host "`n=== COMMUNICATION & MEDIA ===" -ForegroundColor Magenta
    
    # Facebook Messenger
    Ask-InstallSoftware -SoftwareName "Facebook Messenger" -WingetID "Facebook.Messenger" -ChocoPackage "messenger" -Description "Facebook messaging app"
    
    # WhatsApp Desktop
    Ask-InstallSoftware -SoftwareName "WhatsApp Desktop" -WingetID "WhatsApp.WhatsApp" -ChocoPackage "whatsapp" -Description "WhatsApp messaging app"
    
    # PotPlayer
    Ask-InstallSoftware -SoftwareName "PotPlayer" -WingetID "Daum.PotPlayer" -ChocoPackage "potplayer" -Description "Media player"
    
    # VLC Media Player
    Ask-InstallSoftware -SoftwareName "VLC Media Player" -WingetID "VideoLAN.VLC" -ChocoPackage "vlc" -Description "Multimedia player"
    
    # ===================================================================
    # BROWSERS & WEB TOOLS
    # ===================================================================
    Write-Host "`n=== BROWSERS & WEB TOOLS ===" -ForegroundColor Magenta
    
    # Google Chrome
    Ask-InstallSoftware -SoftwareName "Google Chrome" -WingetID "Google.Chrome" -ChocoPackage "googlechrome" -Description "Web browser"
    
    # Mozilla Firefox
    Ask-InstallSoftware -SoftwareName "Mozilla Firefox" -WingetID "Mozilla.Firefox" -ChocoPackage "firefox" -Description "Web browser"
    
    # Postman
    Ask-InstallSoftware -SoftwareName "Postman" -WingetID "Postman.Postman" -ChocoPackage "postman" -Description "API development platform"
    
    # ===================================================================
    # ADDITIONAL UTILITIES
    # ===================================================================
    Write-Host "`n=== ADDITIONAL UTILITIES ===" -ForegroundColor Magenta
    
    # 7-Zip
    Ask-InstallSoftware -SoftwareName "7-Zip" -WingetID "7zip.7zip" -ChocoPackage "7zip" -Description "File archiver"
    
    # Everything Search
    Ask-InstallSoftware -SoftwareName "Everything" -WingetID "voidtools.Everything" -ChocoPackage "everything" -Description "Fast file search tool"
    
    # TreeSize Free
    Ask-InstallSoftware -SoftwareName "TreeSize Free" -WingetID "JAMSoftware.TreeSize.Free" -ChocoPackage "treesizefree" -Description "Disk space analyzer"
    
    # Windows Subsystem for Linux
    Write-Host "`nInstalling Windows Subsystem for Linux (WSL)..." -ForegroundColor Cyan
    try {
        wsl --install --no-launch
        Write-Host "WSL installation initiated. Please restart to complete installation." -ForegroundColor Yellow
    } catch {
        Write-Host "WSL installation failed. Please install manually via 'wsl --install'" -ForegroundColor Red
    }
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- WORK MODE SOFTWARE INSTALLATION ---" -ForegroundColor Cyan
    
    # Office 365 Enterprise - automatic installation for work
    Write-Host "Installing Office 365 Enterprise..." -ForegroundColor Yellow
    Install-Software -SoftwareName "Office 365 Enterprise" -WingetID "Microsoft.Office" -ChocoPackage "office365business" -Silent $true
    
    # Dell Command Update - automatic installation for work
    Write-Host "Installing Dell Command Update..." -ForegroundColor Yellow
    Install-Software -SoftwareName "Dell Command Update" -WingetID "Dell.CommandUpdate" -ChocoPackage "DellCommandUpdate" -Silent $true
    
    # Essential work tools
    Write-Host "Installing essential work tools..." -ForegroundColor Yellow
    Install-Software -SoftwareName "Windows Terminal" -WingetID "Microsoft.WindowsTerminal" -ChocoPackage "microsoft-windows-terminal" -Silent $true
    Install-Software -SoftwareName "PowerToys" -WingetID "Microsoft.PowerToys" -ChocoPackage "powertoys" -Silent $true
    Install-Software -SoftwareName "Sysinternals Suite" -WingetID "Microsoft.Sysinternals" -ChocoPackage "sysinternals" -Silent $true
    Install-Software -SoftwareName "Notepad++" -WingetID "Notepad++.Notepad++" -ChocoPackage "notepadplusplus" -Silent $true
    Install-Software -SoftwareName "7-Zip" -WingetID "7zip.7zip" -ChocoPackage "7zip" -Silent $true
}

# Alternative installations (commented out)
# choco install googlechrome -y --force --params "ALLUSERS=1" 
# choco install adobereader -y --force --params "ALLUSERS=1"

# ===================================================================
# COMPUTER NAMING
# ===================================================================

Write-Host "Configuring computer name..." -ForegroundColor Green

# Rename computer based on BIOS serial number
try {
    $compDetails = Get-ComputerInfo
    
    # Check if BIOS serial number is available and valid
    $biosSerial = $null
    if ($compDetails.BiosSeralNumber -and $compDetails.BiosSeralNumber.Trim() -ne "" -and $compDetails.BiosSeralNumber -ne "To be filled by O.E.M.") {
        $biosSerial = $compDetails.BiosSeralNumber.Trim()
    } elseif ($compDetails.BiosSerialNumber -and $compDetails.BiosSerialNumber.Trim() -ne "" -and $compDetails.BiosSerialNumber -ne "To be filled by O.E.M.") {
        # Try alternative property name (some systems use BiosSerialNumber instead of BiosSeralNumber)
        $biosSerial = $compDetails.BiosSerialNumber.Trim()
    } else {
        # Try WMI as fallback
        try {
            $wmiSerial = (Get-WmiObject -Class Win32_BIOS).SerialNumber
            if ($wmiSerial -and $wmiSerial.Trim() -ne "" -and $wmiSerial -ne "To be filled by O.E.M.") {
                $biosSerial = $wmiSerial.Trim()
                Write-Host "Using WMI BIOS serial number as fallback" -ForegroundColor Yellow
            }
        } catch {
            Write-Host "Could not retrieve BIOS serial via WMI" -ForegroundColor Yellow
        }
    }
    
    if ($biosSerial) {
        # Clean the serial number (remove special characters, spaces)
        $cleanSerial = $biosSerial -replace '[^\w]', ''
        
        # Limit length to avoid Windows computer name limitations (15 characters max)
        if ($cleanSerial.Length -gt 10) {
            $cleanSerial = $cleanSerial.Substring(0, 10)
        }
        
        $newName = "IE-$cleanSerial"
        $currentName = $compDetails.CsName
        
        Write-Host "Current computer name: $currentName" -ForegroundColor White
        Write-Host "BIOS Serial Number: $biosSerial" -ForegroundColor White
        Write-Host "Proposed new name: $newName" -ForegroundColor Cyan
        
        if ($currentName -ne $newName) {
            # Ask user for confirmation
            Write-Host "`n🖥️  COMPUTER NAME CHANGE" -ForegroundColor Yellow
            Write-Host "Do you want to rename the computer from '$currentName' to '$newName'?" -ForegroundColor White
            Write-Host "Note: This will require a restart to take effect." -ForegroundColor Yellow
            Write-Host "Proceed with rename? (y/n): " -NoNewline -ForegroundColor White
            $renameChoice = Read-Host
            
            if ($renameChoice -eq 'y' -or $renameChoice -eq 'Y' -or $renameChoice -eq 'yes') {
                try {
                    Rename-Computer -NewName $newName -Force
                    Write-Host "✅ Computer will be renamed to: $newName (restart required)" -ForegroundColor Green
                } catch {
                    Write-Host "❌ Failed to rename computer: $($_.Exception.Message)" -ForegroundColor Red
                    
                    # Try alternative method using WMI
                    try {
                        $computer = Get-WmiObject -Class Win32_ComputerSystem
                        $computer.Rename($newName)
                        Write-Host "✅ Computer rename scheduled via WMI: $newName (restart required)" -ForegroundColor Green
                    } catch {
                        Write-Host "❌ Alternative rename method also failed: $($_.Exception.Message)" -ForegroundColor Red
                    }
                }
            } else {
                Write-Host "Computer rename cancelled by user." -ForegroundColor Yellow
            }
        } else {
            Write-Host "✅ Computer name is already correct: $currentName" -ForegroundColor Green
        }
    } else {
        Write-Host "⚠️  BIOS serial number not available or invalid" -ForegroundColor Yellow
        Write-Host "Available BIOS information:" -ForegroundColor White
        Write-Host "  - BiosSeralNumber: '$($compDetails.BiosSeralNumber)'" -ForegroundColor Gray
        Write-Host "  - BiosSerialNumber: '$($compDetails.BiosSerialNumber)'" -ForegroundColor Gray
        
        # Try to get additional system information for alternative naming
        try {
            $systemInfo = Get-WmiObject -Class Win32_ComputerSystemProduct
            Write-Host "  - System Serial: '$($systemInfo.SerialNumber)'" -ForegroundColor Gray
            Write-Host "  - System UUID: '$($systemInfo.UUID)'" -ForegroundColor Gray
        } catch {
            Write-Host "  - Could not retrieve additional system information" -ForegroundColor Gray
        }
        
        Write-Host "`nWould you like to enter a custom computer name? (y/n): " -NoNewline -ForegroundColor White
        $customNameChoice = Read-Host
        
        if ($customNameChoice -eq 'y' -or $customNameChoice -eq 'Y' -or $customNameChoice -eq 'yes') {
            Write-Host "Enter new computer name (max 15 characters, letters/numbers only): " -NoNewline -ForegroundColor White
            $customName = Read-Host
            
            # Validate custom name
            if ($customName -and $customName.Length -le 15 -and $customName -match '^[a-zA-Z0-9-]+

# ===================================================================
# SYSTEM RESTART AND CLEANUP
# ===================================================================

Write-Host "Restarting Windows Explorer..." -ForegroundColor Green
# Restart Windows Explorer to apply UI changes
Get-Process explorer | Stop-Process -Force

# ===================================================================
# DIAGNOSTIC INFORMATION
# ===================================================================

Write-Host "Gathering startup program information..." -ForegroundColor Green
# Display startup programs for diagnostic purposes
Get-CimInstance Win32_StartupCommand | Select-Object Name, Command, Location, User | Format-List

# ===================================================================
# PRIVACY AND TELEMETRY CONFIGURATION
# ===================================================================

Write-Host "Configuring privacy settings and disabling telemetry..." -ForegroundColor Green

# Function to safely add registry entries
function Set-RegistryValue {
    param(
        [string]$Path,
        [string]$Name,
        [string]$Type,
        [string]$Value,
        [string]$Description = ""
    )
    
    try {
        # Convert registry path format
        $psPath = $Path -replace 'HKEY_LOCAL_MACHINE', 'HKLM:' -replace 'HKEY_CURRENT_USER', 'HKCU:'
        
        # Check if the registry path exists, create if it doesn't
        if (!(Test-Path $psPath)) {
            $parentPath = Split-Path $psPath -Parent
            if (!(Test-Path $parentPath)) {
                # Create parent path if needed
                New-Item -Path $parentPath -Force | Out-Null
            }
            New-Item -Path $psPath -Force | Out-Null
            Write-Host "Created registry path: $psPath" -ForegroundColor Yellow
        }
        
        # Add the registry value
        reg add "$Path" /v "$Name" /t "$Type" /d "$Value" /f
        if ($LASTEXITCODE -eq 0) {
            Write-Host "✓ Set registry: $Path\$Name = $Value" -ForegroundColor Green
            if ($Description) {
                Write-Host "  Purpose: $Description" -ForegroundColor Gray
            }
        } else {
            Write-Host "✗ Failed to set registry: $Path\$Name" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Registry error for $Path\$Name : $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Disable Windows telemetry and data collection
Write-Host "`nDisabling telemetry and data collection..." -ForegroundColor Yellow

Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" -Name "AllowTelemetry" -Type "REG_DWORD" -Value "0" -Description "Disable telemetry data collection"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection" -Name "AllowTelemetry" -Type "REG_DWORD" -Value "0" -Description "Disable telemetry (alternative path)"

# Disable diagnostic data
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Diagnostics\DiagTrack" -Name "ShowedToastAtLevel" -Type "REG_DWORD" -Value "1" -Description "Disable diagnostic tracking toast"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" -Name "AllowDeviceNameInTelemetry" -Type "REG_DWORD" -Value "0" -Description "Disable device name in telemetry"

# Disable Windows Error Reporting
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting" -Name "Disabled" -Type "REG_DWORD" -Value "1" -Description "Disable Windows Error Reporting"

# Disable Customer Experience Improvement Program
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\SQMClient\Windows" -Name "CEIPEnable" -Type "REG_DWORD" -Value "0" -Description "Disable Customer Experience Improvement Program"

# Disable Application Compatibility Telemetry
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" -Name "AITEnable" -Type "REG_DWORD" -Value "0" -Description "Disable Application Compatibility Telemetry"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" -Name "DisableInventory" -Type "REG_DWORD" -Value "1" -Description "Disable application inventory"

# Disable Windows Defender submission of samples
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Name "SubmitSamplesConsent" -Type "REG_DWORD" -Value "2" -Description "Disable sample submission"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Name "SpynetReporting" -Type "REG_DWORD" -Value "0" -Description "Disable SpyNet reporting"

# Disable activity history
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" -Name "EnableActivityFeed" -Type "REG_DWORD" -Value "0" -Description "Disable activity feed"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" -Name "PublishUserActivities" -Type "REG_DWORD" -Value "0" -Description "Disable publishing user activities"

# Disable location tracking
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\LocationAndSensors" -Name "DisableLocation" -Type "REG_DWORD" -Value "1" -Description "Disable location services"
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\location" -Name "Value" -Type "REG_SZ" -Value "Deny" -Description "Deny location access"

# Disable advertising ID
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AdvertisingInfo" -Name "DisabledByGroupPolicy" -Type "REG_DWORD" -Value "1" -Description "Disable advertising ID"
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\AdvertisingInfo" -Name "Enabled" -Type "REG_DWORD" -Value "0" -Description "Disable advertising ID for user"

# Disable sync with Microsoft services
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\SettingSync" -Name "SyncPolicy" -Type "REG_DWORD" -Value "5" -Description "Disable settings sync"

# ===================================================================
# ADVANCED PERFORMANCE OPTIMIZATION
# ===================================================================

Write-Host "Applying advanced performance optimizations..." -ForegroundColor Green

# Disable Windows Search indexing service (alternative method)
# Note: This is now handled in the services section above

# Disable SuperFetch/SysMain (can slow down SSDs)
# Note: This is now handled in the services section above

# Disable Windows Update automatic restart
Write-Host "`nConfiguring Windows Update settings..." -ForegroundColor Yellow
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "NoAutoRebootWithLoggedOnUsers" -Type "REG_DWORD" -Value "1" -Description "Prevent automatic restart with logged on users"
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "AUPowerManagement" -Type "REG_DWORD" -Value "0" -Description "Disable automatic power management for updates"

# Optimize visual effects for performance
Write-Host "`nOptimizing visual effects..." -ForegroundColor Yellow
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VisualEffects" -Name "VisualFXSetting" -Type "REG_DWORD" -Value "2" -Description "Set visual effects for best performance"

# Disable unnecessary animations
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Desktop" -Name "MenuShowDelay" -Type "REG_SZ" -Value "0" -Description "Remove menu show delay"
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics" -Name "MinAnimate" -Type "REG_SZ" -Value "0" -Description "Disable window animations"

# Set processor scheduling for background services
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\PriorityControl" -Name "Win32PrioritySeparation" -Type "REG_DWORD" -Value "24" -Description "Optimize processor scheduling for background services"

# Disable memory compression (Windows 10/11)
Write-Host "`nConfiguring memory compression..." -ForegroundColor Yellow
$memoryChoice = Read-Host "Do you want to disable memory compression? May improve performance on systems with sufficient RAM. (y/n)"
if ($memoryChoice -eq 'y' -or $memoryChoice -eq 'Y' -or $memoryChoice -eq 'yes') {
    try {
        Disable-MMAgent -MemoryCompression
        Write-Host "✓ Memory compression disabled" -ForegroundColor Green
    } catch {
        Write-Host "⚠ Could not disable memory compression: $($_.Exception.Message)" -ForegroundColor Yellow
    }
} else {
    Write-Host "Memory compression will remain enabled" -ForegroundColor Green
}

# Set paging file to system managed on C: drive only
Write-Host "`nConfiguring paging file..." -ForegroundColor Yellow
try {
    $cs = Get-WmiObject -Class Win32_ComputerSystem
    if ($cs.AutomaticManagedPagefile) {
        $pagingChoice = Read-Host "Do you want to let the system manage the paging file automatically? (y/n)"
        if ($pagingChoice -eq 'n' -or $pagingChoice -eq 'N' -or $pagingChoice -eq 'no') {
            $cs.AutomaticManagedPagefile = $false
            $cs.Put()
            Write-Host "✓ Automatic paging file management disabled" -ForegroundColor Yellow
            Write-Host "You may want to manually configure paging file settings" -ForegroundColor Gray
        }
    } else {
        Write-Host "Paging file is already manually managed" -ForegroundColor Green
    }
} catch {
    Write-Host "⚠ Could not configure paging file settings: $($_.Exception.Message)" -ForegroundColor Yellow
}

# ===================================================================
# SECURITY ENHANCEMENTS
# ===================================================================

Write-Host "Applying security enhancements..." -ForegroundColor Green

# Disable Guest account
try {
    Disable-LocalUser -Name "Guest"
    Write-Host "Guest account disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Guest account not found or already disabled" -ForegroundColor Yellow
}

# Enable UAC but reduce prompts for admins
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 2 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v PromptOnSecureDesktop /t REG_DWORD /d 0 /f

# Disable AutoRun for removable media
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v NoDriveTypeAutoRun /t REG_DWORD /d 255 /f

# Set strong password policy
net accounts /minpwlen:8 /maxpwage:90 /lockoutthreshold:5 /lockoutduration:30

# Disable SMB1 protocol (security vulnerability)
try {
    Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -NoRestart
    Write-Host "SMB1 protocol disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable SMB1 protocol" -ForegroundColor Red
}

# ===================================================================
# NETWORK AND INTERNET OPTIMIZATION
# ===================================================================

Write-Host "Optimizing network settings..." -ForegroundColor Green

# Disable Windows Update P2P sharing
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\DeliveryOptimization\Config" /v DODownloadMode /t REG_DWORD /d 0 /f

# Set DNS to Cloudflare (1.1.1.1) for better performance and privacy
try {
    $adapters = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
    foreach ($adapter in $adapters) {
        Set-DnsClientServerAddress -InterfaceAlias $adapter.Name -ServerAddresses "1.1.1.1", "1.0.0.1"
    }
    Write-Host "DNS set to Cloudflare (1.1.1.1, 1.0.0.1)" -ForegroundColor Green
} catch {
    Write-Host "Could not set DNS servers" -ForegroundColor Red
}

# Disable Teredo tunneling (can be security risk)
netsh interface teredo set state disabled

# Disable Windows Connect Now
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v EnableRegistrars /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v DisableUPnPRegistrar /t REG_DWORD /d 0 /f

# ===================================================================
# STARTUP AND SERVICES OPTIMIZATION
# ===================================================================

Write-Host "Optimizing startup and services..." -ForegroundColor Green

# Function to safely disable Windows services
function Disable-WindowsService {
    param(
        [string]$ServiceName,
        [string]$Description = ""
    )
    
    try {
        $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if ($serviceObj) {
            Write-Host "Processing service: $ServiceName" -ForegroundColor Cyan
            
            # Display current status
            Write-Host "  Current status: $($serviceObj.Status)" -ForegroundColor Gray
            Write-Host "  Startup type: $($serviceObj.StartType)" -ForegroundColor Gray
            if ($Description) {
                Write-Host "  Purpose: $Description" -ForegroundColor Gray
            }
            
            # Stop the service if it's running
            if ($serviceObj.Status -eq 'Running') {
                Write-Host "  Stopping service..." -ForegroundColor Yellow
                Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 1  # Brief pause to allow service to stop
                
                # Verify service stopped
                $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
                if ($serviceObj.Status -eq 'Stopped') {
                    Write-Host "  ✓ Service stopped successfully" -ForegroundColor Green
                } else {
                    Write-Host "  ⚠ Service may still be running" -ForegroundColor Yellow
                }
            }
            
            # Disable the service
            Write-Host "  Setting startup type to Disabled..." -ForegroundColor Yellow
            Set-Service -Name $ServiceName -StartupType Disabled -ErrorAction SilentlyContinue
            
            # Verify the change
            $serviceObj = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
            if ($serviceObj.StartType -eq 'Disabled') {
                Write-Host "  ✓ Service disabled successfully: $ServiceName" -ForegroundColor Green
            } else {
                Write-Host "  ⚠ Service may not be properly disabled: $ServiceName" -ForegroundColor Yellow
            }
        } else {
            Write-Host "⚠ Service not found: $ServiceName" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "✗ Error processing service $ServiceName : $($_.Exception.Message)" -ForegroundColor Red
    }
}

# List of services to disable for better performance
Write-Host "`nDisabling unnecessary services..." -ForegroundColor Yellow

$servicesToDisable = @(
    @{ Name = "Fax"; Description = "Fax service - rarely used in modern environments" },
    @{ Name = "WMPNetworkSvc"; Description = "Windows Media Player Network Sharing Service" },
    @{ Name = "TabletInputService"; Description = "Tablet PC Input Service - not needed on desktop PCs" },
    @{ Name = "TrkWks"; Description = "Distributed Link Tracking Client - tracks file shortcuts" },
    @{ Name = "WerSvc"; Description = "Windows Error Reporting Service" },
    @{ Name = "DiagTrack"; Description = "Connected User Experiences and Telemetry" },
    @{ Name = "dmwappushservice"; Description = "WAP Push Message Routing Service - mobile networks" },
    @{ Name = "MapsBroker"; Description = "Downloaded Maps Manager" },
    @{ Name = "lfsvc"; Description = "Geolocation Service" },
    @{ Name = "RetailDemo"; Description = "Retail Demo Service - used in store displays" },
    @{ Name = "RemoteRegistry"; Description = "Remote Registry - security risk if not needed" },
    @{ Name = "SharedAccess"; Description = "Internet Connection Sharing (ICS)" },
    @{ Name = "SSDPSRV"; Description = "SSDP Discovery - UPnP device discovery" },
    @{ Name = "upnphost"; Description = "UPnP Device Host" },
    @{ Name = "WSearch"; Description = "Windows Search - will be handled separately" }
)

foreach ($service in $servicesToDisable) {
    Disable-WindowsService -ServiceName $service.Name -Description $service.Description
}

# Special handling for Windows Search service
Write-Host "`nHandling Windows Search service..." -ForegroundColor Yellow
$searchChoice = Read-Host "Do you want to disable Windows Search indexing? This will improve performance but slow down file searches. (y/n)"
if ($searchChoice -eq 'y' -or $searchChoice -eq 'Y' -or $searchChoice -eq 'yes') {
    Disable-WindowsService -ServiceName "WSearch" -Description "Windows Search indexing service"
} else {
    Write-Host "Windows Search service will remain enabled" -ForegroundColor Green
}

# Special handling for SuperFetch/SysMain
Write-Host "`nHandling SysMain (SuperFetch) service..." -ForegroundColor Yellow
$sysmainChoice = Read-Host "Do you want to disable SysMain (SuperFetch)? Recommended for SSDs. (y/n)"
if ($sysmainChoice -eq 'y' -or $sysmainChoice -eq 'Y' -or $sysmainChoice -eq 'yes') {
    Disable-WindowsService -ServiceName "SysMain" -Description "System Maintenance service (SuperFetch) - can slow down SSDs"
} else {
    Write-Host "SysMain service will remain enabled" -ForegroundColor Green
}

# ===================================================================
# REGISTRY CLEANUP AND OPTIMIZATION
# ===================================================================

Write-Host "Performing registry optimizations..." -ForegroundColor Green

# Disable Windows Tips and Tricks
Write-Host "`nDisabling Windows tips and consumer features..." -ForegroundColor Yellow
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" -Name "SoftLandingEnabled" -Type "REG_DWORD" -Value "0" -Description "Disable soft landing tips"
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" -Name "SystemPaneSuggestionsEnabled" -Type "REG_DWORD" -Value "0" -Description "Disable system pane suggestions"

# Disable consumer features (suggested apps)
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CloudContent" -Name "DisableWindowsConsumerFeatures" -Type "REG_DWORD" -Value "1" -Description "Disable Windows consumer features and app suggestions"

# Disable Windows Ink workspace
Set-RegistryValue -Path "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsInkWorkspace" -Name "AllowWindowsInkWorkspace" -Type "REG_DWORD" -Value "0" -Description "Disable Windows Ink workspace"

# Disable People icon in taskbar
Set-RegistryValue -Path "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\People" -Name "PeopleBand" -Type "REG_DWORD" -Value "0" -Description "Hide People icon from taskbar"

# Disable Sticky Keys prompt
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Accessibility\StickyKeys" -Name "Flags" -Type "REG_SZ" -Value "506" -Description "Disable Sticky Keys prompt"

# Disable Filter Keys prompt  
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Accessibility\Keyboard Response" -Name "Flags" -Type "REG_SZ" -Value "122" -Description "Disable Filter Keys prompt"

# Disable Toggle Keys prompt
Set-RegistryValue -Path "HKEY_CURRENT_USER\Control Panel\Accessibility\ToggleKeys" -Name "Flags" -Type "REG_SZ" -Value "58" -Description "Disable Toggle Keys prompt"

# ===================================================================
# ADDITIONAL SOFTWARE MANAGEMENT
# ===================================================================

Write-Host "Managing additional software..." -ForegroundColor Green

# List of built-in apps to remove (Windows 10/11 bloatware)
$appsToRemove = @(
    "Microsoft.3DBuilder",
    "Microsoft.BingFinance",
    "Microsoft.BingNews", 
    "Microsoft.BingSports",
    "Microsoft.BingWeather",
    "Microsoft.GetHelp",
    "Microsoft.Getstarted",
    "Microsoft.Messaging",
    "Microsoft.Microsoft3DViewer",
    "Microsoft.MicrosoftOfficeHub",
    "Microsoft.MicrosoftSolitaireCollection",
    "Microsoft.NetworkSpeedTest",
    "Microsoft.News",
    "Microsoft.Office.Lens",
    "Microsoft.Office.OneNote",
    "Microsoft.Office.Sway",
    "Microsoft.OneConnect",
    "Microsoft.People",
    "Microsoft.Print3D",
    "Microsoft.RemoteDesktop",
    "Microsoft.SkypeApp",
    "Microsoft.Wallet",
    "Microsoft.Whiteboard",
    "Microsoft.WindowsAlarms",
    "Microsoft.WindowsCamera",
    "microsoft.windowscommunicationsapps",
    "Microsoft.WindowsFeedbackHub",
    "Microsoft.WindowsMaps",
    "Microsoft.WindowsSoundRecorder",
    "Microsoft.Xbox.TCUI",
    "Microsoft.XboxApp",
    "Microsoft.XboxGameOverlay",
    "Microsoft.XboxGamingOverlay",
    "Microsoft.XboxIdentityProvider",
    "Microsoft.XboxSpeechToTextOverlay",
    "Microsoft.ZuneMusic",
    "Microsoft.ZuneVideo"
)

foreach ($app in $appsToRemove) {
    try {
        Get-AppxPackage -Name $app -AllUsers | Remove-AppxPackage -ErrorAction SilentlyContinue
        Get-AppxProvisionedPackage -Online | Where-Object DisplayName -like $app | Remove-AppxProvisionedPackage -Online -ErrorAction SilentlyContinue
        Write-Host "Removed app: $app" -ForegroundColor Yellow
    } catch {
        # Silently continue if app is not found
    }
}

# ===================================================================
# DISK CLEANUP AND MAINTENANCE
# ===================================================================

Write-Host "Performing disk cleanup..." -ForegroundColor Green

# Clean temporary files
Remove-Item -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "$env:LOCALAPPDATA\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue

# Clear Windows Update cache
try {
    Stop-Service wuauserv -Force
    Remove-Item -Path "$env:WINDIR\SoftwareDistribution\Download\*" -Recurse -Force -ErrorAction SilentlyContinue
    Start-Service wuauserv
    Write-Host "Windows Update cache cleared" -ForegroundColor Yellow
} catch {
    Write-Host "Could not clear Windows Update cache" -ForegroundColor Red
}

# Enable Storage Sense (automatic cleanup)
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy" /v 01 /t REG_DWORD /d 1 /f

# ===================================================================
# CONFIGURATION RESTORE SYSTEM
# ===================================================================

function Get-CurrentlyInstalledApplications {
    Write-Host "Scanning currently installed applications..." -ForegroundColor Cyan
    
    $currentApps = @{}
    
    # Get currently installed software using the same methods as discovery
    try {
        # Registry 64-bit
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg64) {
            $currentApps[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
        
        # Registry 32-bit
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $currentApps.ContainsKey($app.DisplayName)) {
                $currentApps[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
        
        # Store Apps
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            if (-not $currentApps.ContainsKey($app.Name)) {
                $currentApps[$app.Name] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
        
        Write-Host "Found $($currentApps.Count) currently installed applications" -ForegroundColor Green
        return $currentApps
        
    } catch {
        Write-Host "Error scanning installed applications: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Find-AvailableBackups {
    param([string]$BackupBasePath)
    
    Write-Host "Searching for available backups in: $BackupBasePath" -ForegroundColor Cyan
    
    if (!(Test-Path $BackupBasePath)) {
        Write-Host "Backup base path does not exist: $BackupBasePath" -ForegroundColor Red
        return @{}
    }
    
    $availableBackups = @{}
    
    try {
        # Find all backup sessions (timestamp directories)
        $backupSessions = Get-ChildItem $BackupBasePath -Directory | 
            Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "`n💾 BACKUP/RESTORE INFORMATION:" -ForegroundColor Yellow
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    if ($Restore) {
        Write-Host "• Interactive restore: Current configs backed up before restore" -ForegroundColor White
        Write-Host "• Restore logs available in backup base path" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White
Write-Host "Restore configurations: .\script.ps1 -Mode home -Restore" -ForegroundColor White
Write-Host "Restore with custom path: .\script.ps1 -Mode home -Restore -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    if (-not $Restore) {
        Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    }
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
    if ($Restore) {
        Write-Host "Before-restore backups: BackupBasePath\beforeRestoreBackup_YYYY-MM-DD_HH-MM-SS\[AppName]" -ForegroundColor Gray
    }
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan } |
            Sort-Object Name -Descending
        
        foreach ($session in $backupSessions) {
            $sessionPath = $session.FullName
            $sessionName = $session.Name
            
            # Check for StandardSoftwareBackup
            $standardBackupPath = Join-Path $sessionPath "StandardSoftwareBackup\AppData"
            if (Test-Path $standardBackupPath) {
                $standardApps = Get-ChildItem $standardBackupPath -Directory
                foreach ($app in $standardApps) {
                    $appName = $app.Name
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Standard"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
            
            # Check for ComprehensiveSoftwareBackup
            $comprehensiveBackupPath = Join-Path $sessionPath "ComprehensiveSoftwareBackup\Applications"
            if (Test-Path $comprehensiveBackupPath) {
                $comprehensiveApps = Get-ChildItem $comprehensiveBackupPath -Directory
                foreach ($app in $comprehensiveApps) {
                    $appName = $app.Name -replace '_', ' '  # Restore original name format
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Comprehensive"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
        }
        
        Write-Host "Found backups for $($availableBackups.Count) applications across $($backupSessions.Count) sessions" -ForegroundColor Green
        return $availableBackups
        
    } catch {
        Write-Host "Error searching for backups: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Backup-CurrentConfiguration {
    param(
        [string]$AppName,
        [string]$RestoreBackupPath,
        [string]$BackupBasePath
    )
    
    try {
        # Create beforeRestore backup directory
        $beforeRestoreTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
        $beforeRestorePath = "$BackupBasePath\beforeRestoreBackup_$beforeRestoreTimestamp\$($AppName -replace '[^\w\s-]', '_')"
        New-Item -Path $beforeRestorePath -ItemType Directory -Force | Out-Null
        
        # Get current configuration paths for the application
        $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
        
        $backupSuccess = $false
        
        # Backup current configuration files
        foreach ($configPath in $paths.ConfigPaths) {
            try {
                if (Test-Path $configPath) {
                    $destinationPath = Join-Path $beforeRestorePath (Split-Path $configPath -Leaf)
                    if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                        Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force
                    } else {
                        Copy-Item -Path $configPath -Destination $destinationPath -Force
                    }
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current: $(Split-Path $configPath -Leaf)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup: $configPath" -ForegroundColor Yellow
            }
        }
        
        # Backup current registry keys
        foreach ($regPath in $paths.RegistryPaths) {
            try {
                $regFileName = "$beforeRestorePath\$($AppName -replace '[^\w\s-]', '_')_current_registry.reg"
                reg export "$regPath" "$regFileName" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current registry: $regPath" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup registry: $regPath" -ForegroundColor Yellow
            }
        }
        
        if ($backupSuccess) {
            # Create metadata file
            $metadata = @{
                AppName = $AppName
                BackupDate = Get-Date
                RestoreSource = $RestoreBackupPath
                Purpose = "BeforeRestore"
            }
            $metadata | ConvertTo-Json | Out-File "$beforeRestorePath\backup_metadata.json" -Encoding UTF8
            
            Write-Host "✅ Current configuration backed up to: $beforeRestorePath" -ForegroundColor Green
            return $beforeRestorePath
        } else {
            Write-Host "⚠ No current configuration found to backup for: $AppName" -ForegroundColor Yellow
            return $null
        }
        
    } catch {
        Write-Host "❌ Failed to backup current configuration: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Restore-ApplicationConfiguration {
    param(
        [string]$AppName,
        [string]$BackupPath,
        [string]$BackupBasePath
    )
    
    Write-Host "`n🔄 RESTORING CONFIGURATION FOR: $AppName" -ForegroundColor Cyan
    Write-Host "From backup: $BackupPath" -ForegroundColor Gray
    
    try {
        # First, backup current configuration
        Write-Host "`n📦 Creating backup of current configuration..." -ForegroundColor Yellow
        $beforeRestoreBackup = Backup-CurrentConfiguration -AppName $AppName -RestoreBackupPath $BackupPath -BackupBasePath $BackupBasePath
        
        $restoreSuccess = $false
        $restoredItems = @()
        
        # Restore configuration files
        Write-Host "`n📂 Restoring configuration files..." -ForegroundColor Yellow
        $configFiles = Get-ChildItem $BackupPath -File | Where-Object { $_.Name -notlike "*.reg" -and $_.Name -ne "backup_metadata.json" }
        
        foreach ($file in $configFiles) {
            try {
                # Try to determine target path based on file name and application
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetFile = Join-Path $parentDir $file.Name
                        Copy-Item -Path $file.FullName -Destination $targetFile -Force
                        Write-Host "✓ Restored: $($file.Name) → $targetFile" -ForegroundColor Green
                        $restoredItems += $targetFile
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for: $($file.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore: $($file.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore configuration directories
        $configDirs = Get-ChildItem $BackupPath -Directory
        foreach ($dir in $configDirs) {
            try {
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetDir = Join-Path $parentDir $dir.Name
                        Copy-Item -Path $dir.FullName -Destination $targetDir -Recurse -Force
                        Write-Host "✓ Restored directory: $($dir.Name) → $targetDir" -ForegroundColor Green
                        $restoredItems += $targetDir
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for directory: $($dir.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore directory: $($dir.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore registry entries
        Write-Host "`n🔧 Restoring registry entries..." -ForegroundColor Yellow
        $regFiles = Get-ChildItem $BackupPath -Filter "*.reg"
        
        foreach ($regFile in $regFiles) {
            try {
                Write-Host "Importing registry: $($regFile.Name)" -ForegroundColor Cyan
                reg import "$($regFile.FullName)" /reg:64
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Registry imported: $($regFile.Name)" -ForegroundColor Green
                    $restoredItems += $regFile.FullName
                    $restoreSuccess = $true
                } else {
                    Write-Host "✗ Registry import failed: $($regFile.Name)" -ForegroundColor Red
                }
            } catch {
                Write-Host "✗ Registry import error: $($regFile.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Create restore log
        if ($restoreSuccess) {
            $restoreLog = @{
                AppName = $AppName
                RestoreDate = Get-Date
                SourceBackup = $BackupPath
                BeforeRestoreBackup = $beforeRestoreBackup
                RestoredItems = $restoredItems
                Status = "Success"
            }
            
            $logPath = "$BackupBasePath\restore_log_$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss').json"
            $restoreLog | ConvertTo-Json -Depth 3 | Out-File $logPath -Encoding UTF8
            
            Write-Host "`n✅ RESTORE COMPLETED SUCCESSFULLY" -ForegroundColor Green
            Write-Host "Restored items: $($restoredItems.Count)" -ForegroundColor White
            Write-Host "Restore log: $logPath" -ForegroundColor White
            if ($beforeRestoreBackup) {
                Write-Host "Current config backed up to: $beforeRestoreBackup" -ForegroundColor White
            }
            
            return $true
        } else {
            Write-Host "`n❌ RESTORE FAILED - No items were successfully restored" -ForegroundColor Red
            return $false
        }
        
    } catch {
        Write-Host "`n❌ RESTORE ERROR: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

function Start-ConfigurationRestore {
    param([string]$BackupBasePath)
    
    Write-Host "`n🔄 CONFIGURATION RESTORE MODE" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    
    # Get currently installed applications
    $currentApps = Get-CurrentlyInstalledApplications
    if ($currentApps.Count -eq 0) {
        Write-Host "No installed applications found. Cannot proceed with restore." -ForegroundColor Red
        return
    }
    
    # Find available backups
    $availableBackups = Find-AvailableBackups -BackupBasePath $BackupBasePath
    if ($availableBackups.Count -eq 0) {
        Write-Host "No configuration backups found in: $BackupBasePath" -ForegroundColor Red
        return
    }
    
    # Find applications that are both installed and have backups
    $restorableApps = @{}
    foreach ($appName in $availableBackups.Keys) {
        # Try to match app names (exact match or partial match)
        $matchingApp = $null
        foreach ($installedApp in $currentApps.Keys) {
            if ($installedApp -eq $appName -or 
                $installedApp -like "*$appName*" -or 
                $appName -like "*$installedApp*") {
                $matchingApp = $installedApp
                break
            }
        }
        
        if ($matchingApp) {
            $restorableApps[$appName] = @{
                InstalledName = $matchingApp
                Backups = $availableBackups[$appName]
            }
        }
    }
    
    if ($restorableApps.Count -eq 0) {
        Write-Host "No restorable applications found." -ForegroundColor Yellow
        Write-Host "This means no installed applications have available configuration backups." -ForegroundColor Yellow
        return
    }
    
    Write-Host "`n📋 RESTORABLE APPLICATIONS:" -ForegroundColor Green
    Write-Host "Found $($restorableApps.Count) applications with available backups" -ForegroundColor White
    
    # Display restorable applications
    $appIndex = 1
    $appList = @()
    foreach ($app in $restorableApps.GetEnumerator()) {
        $appList += $app
        Write-Host "$appIndex. $($app.Key) ($($app.Value.Backups.Count) backup(s) available)" -ForegroundColor Cyan
        $appIndex++
    }
    
    # Application selection loop
    do {
        Write-Host "`n🎯 SELECT APPLICATION TO RESTORE:" -ForegroundColor Yellow
        Write-Host "Enter application number (1-$($appList.Count)) or 'q' to quit: " -NoNewline
        $selection = Read-Host
        
        if ($selection -eq 'q' -or $selection -eq 'Q') {
            Write-Host "Restore cancelled by user." -ForegroundColor Yellow
            return
        }
        
        if ($selection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$selection -ge 1 -and [int]$selection -le $appList.Count) {
            $selectedApp = $appList[[int]$selection - 1]
            $appName = $selectedApp.Key
            $appBackups = $selectedApp.Value.Backups
            
            Write-Host "`n📦 AVAILABLE BACKUPS FOR: $appName" -ForegroundColor Cyan
            
            # Display available backups
            $backupIndex = 1
            foreach ($backup in $appBackups) {
                Write-Host "$backupIndex. Session: $($backup.Session) | Type: $($backup.Type) | Date: $($backup.BackupDate)" -ForegroundColor White
                $backupIndex++
            }
            
            # Backup selection
            Write-Host "`nSelect backup number (1-$($appBackups.Count)) or 'b' to go back: " -NoNewline
            $backupSelection = Read-Host
            
            if ($backupSelection -eq 'b' -or $backupSelection -eq 'B') {
                continue  # Go back to app selection
            }
            
            if ($backupSelection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$backupSelection -ge 1 -and [int]$backupSelection -le $appBackups.Count) {
                $selectedBackup = $appBackups[[int]$backupSelection - 1]
                
                Write-Host "`n⚠️  CONFIRMATION REQUIRED" -ForegroundColor Yellow
                Write-Host "You are about to restore configuration for: $appName" -ForegroundColor White
                Write-Host "From backup: $($selectedBackup.Session) ($($selectedBackup.Type))" -ForegroundColor White
                Write-Host "Current configuration will be backed up before restore." -ForegroundColor White
                Write-Host "`nProceed with restore? (y/n): " -NoNewline
                $confirm = Read-Host
                
                if ($confirm -eq 'y' -or $confirm -eq 'Y' -or $confirm -eq 'yes') {
                    $restoreResult = Restore-ApplicationConfiguration -AppName $appName -BackupPath $selectedBackup.Path -BackupBasePath $BackupBasePath
                    
                    if ($restoreResult) {
                        Write-Host "`n🎉 Configuration restored successfully!" -ForegroundColor Green
                        Write-Host "You may need to restart the application to see changes." -ForegroundColor Yellow
                    } else {
                        Write-Host "`n💥 Configuration restore failed!" -ForegroundColor Red
                    }
                    
                    Write-Host "`nRestore another application? (y/n): " -NoNewline
                    $continueRestore = Read-Host
                    if ($continueRestore -ne 'y' -and $continueRestore -ne 'Y' -and $continueRestore -ne 'yes') {
                        break
                    }
                } else {
                    Write-Host "Restore cancelled." -ForegroundColor Yellow
                }
            } else {
                Write-Host "Invalid backup selection." -ForegroundColor Red
            }
        } else {
            Write-Host "Invalid application selection." -ForegroundColor Red
        }
    } while ($true)
    
    Write-Host "`n✅ RESTORE SESSION COMPLETED" -ForegroundColor Green
}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan) {
                $currentName = $compDetails.CsName
                if ($currentName -ne $customName) {
                    try {
                        Rename-Computer -NewName $customName -Force
                        Write-Host "✅ Computer will be renamed to: $customName (restart required)" -ForegroundColor Green
                    } catch {
                        Write-Host "❌ Failed to rename computer: $($_.Exception.Message)" -ForegroundColor Red
                    }
                } else {
                    Write-Host "Computer name is already: $customName" -ForegroundColor Yellow
                }
            } else {
                Write-Host "❌ Invalid computer name. Must be 1-15 characters, letters/numbers/hyphens only." -ForegroundColor Red
            }
        } else {
            Write-Host "Computer name will remain unchanged: $($compDetails.CsName)" -ForegroundColor Yellow
        }
    }
    
} catch {
    Write-Host "❌ Error configuring computer name: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Computer name will remain unchanged." -ForegroundColor Yellow
}

# ===================================================================
# SYSTEM RESTART AND CLEANUP
# ===================================================================

Write-Host "Restarting Windows Explorer..." -ForegroundColor Green
# Restart Windows Explorer to apply UI changes
Get-Process explorer | Stop-Process -Force

# ===================================================================
# DIAGNOSTIC INFORMATION
# ===================================================================

Write-Host "Gathering startup program information..." -ForegroundColor Green
# Display startup programs for diagnostic purposes
Get-CimInstance Win32_StartupCommand | Select-Object Name, Command, Location, User | Format-List

# ===================================================================
# PRIVACY AND TELEMETRY CONFIGURATION
# ===================================================================

Write-Host "Configuring privacy settings and disabling telemetry..." -ForegroundColor Green

# Disable Windows telemetry and data collection
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f

# Disable diagnostic data
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Diagnostics\DiagTrack" /v ShowedToastAtLevel /t REG_DWORD /d 1 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection" /v AllowDeviceNameInTelemetry /t REG_DWORD /d 0 /f

# Disable Windows Error Reporting
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting" /v Disabled /t REG_DWORD /d 1 /f

# Disable Customer Experience Improvement Program
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\SQMClient\Windows" /v CEIPEnable /t REG_DWORD /d 0 /f

# Disable Application Compatibility Telemetry
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" /v AITEnable /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppCompat" /v DisableInventory /t REG_DWORD /d 1 /f

# Disable Windows Defender submission of samples
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v SubmitSamplesConsent /t REG_DWORD /d 2 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v SpynetReporting /t REG_DWORD /d 0 /f

# Disable activity history
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" /v EnableActivityFeed /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" /v PublishUserActivities /t REG_DWORD /d 0 /f

# Disable location tracking
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\LocationAndSensors" /v DisableLocation /t REG_DWORD /d 1 /f
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\location" /v Value /t REG_SZ /d "Deny" /f

# Disable advertising ID
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AdvertisingInfo" /v DisabledByGroupPolicy /t REG_DWORD /d 1 /f
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\AdvertisingInfo" /v Enabled /t REG_DWORD /d 0 /f

# Disable sync with Microsoft services
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\SettingSync" /v SyncPolicy /t REG_DWORD /d 5 /f

# ===================================================================
# ADVANCED PERFORMANCE OPTIMIZATION
# ===================================================================

Write-Host "Applying advanced performance optimizations..." -ForegroundColor Green

# Disable Windows Search indexing service (alternative method)
try {
    Stop-Service "WSearch" -Force
    Set-Service "WSearch" -StartupType Disabled
    Write-Host "Windows Search service disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable Windows Search service" -ForegroundColor Red
}

# Disable SuperFetch/SysMain (can slow down SSDs)
try {
    Stop-Service "SysMain" -Force
    Set-Service "SysMain" -StartupType Disabled
    Write-Host "SysMain (SuperFetch) service disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable SysMain service" -ForegroundColor Red
}

# Disable Windows Update automatic restart
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" /v NoAutoRebootWithLoggedOnUsers /t REG_DWORD /d 1 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" /v AUPowerManagement /t REG_DWORD /d 0 /f

# Optimize visual effects for performance
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VisualEffects" /v VisualFXSetting /t REG_DWORD /d 2 /f

# Disable unnecessary animations
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v MenuShowDelay /t REG_SZ /d "0" /f
reg add "HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics" /v MinAnimate /t REG_SZ /d "0" /f

# Set processor scheduling for background services
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\PriorityControl" /v Win32PrioritySeparation /t REG_DWORD /d 24 /f

# Disable memory compression (Windows 10/11)
try {
    Disable-MMAgent -MemoryCompression
    Write-Host "Memory compression disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable memory compression" -ForegroundColor Red
}

# Set paging file to system managed on C: drive only
$cs = Get-WmiObject -Class Win32_ComputerSystem
if ($cs.AutomaticManagedPagefile) {
    $cs.AutomaticManagedPagefile = $false
    $cs.Put()
}

# ===================================================================
# SECURITY ENHANCEMENTS
# ===================================================================

Write-Host "Applying security enhancements..." -ForegroundColor Green

# Disable Guest account
try {
    Disable-LocalUser -Name "Guest"
    Write-Host "Guest account disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Guest account not found or already disabled" -ForegroundColor Yellow
}

# Enable UAC but reduce prompts for admins
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 2 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v PromptOnSecureDesktop /t REG_DWORD /d 0 /f

# Disable AutoRun for removable media
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v NoDriveTypeAutoRun /t REG_DWORD /d 255 /f

# Set strong password policy
net accounts /minpwlen:8 /maxpwage:90 /lockoutthreshold:5 /lockoutduration:30

# Disable SMB1 protocol (security vulnerability)
try {
    Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -NoRestart
    Write-Host "SMB1 protocol disabled" -ForegroundColor Yellow
} catch {
    Write-Host "Could not disable SMB1 protocol" -ForegroundColor Red
}

# ===================================================================
# NETWORK AND INTERNET OPTIMIZATION
# ===================================================================

Write-Host "Optimizing network settings..." -ForegroundColor Green

# Disable Windows Update P2P sharing
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\DeliveryOptimization\Config" /v DODownloadMode /t REG_DWORD /d 0 /f

# Set DNS to Cloudflare (1.1.1.1) for better performance and privacy
try {
    $adapters = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
    foreach ($adapter in $adapters) {
        Set-DnsClientServerAddress -InterfaceAlias $adapter.Name -ServerAddresses "1.1.1.1", "1.0.0.1"
    }
    Write-Host "DNS set to Cloudflare (1.1.1.1, 1.0.0.1)" -ForegroundColor Green
} catch {
    Write-Host "Could not set DNS servers" -ForegroundColor Red
}

# Disable Teredo tunneling (can be security risk)
netsh interface teredo set state disabled

# Disable Windows Connect Now
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v EnableRegistrars /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WCN\Registrars" /v DisableUPnPRegistrar /t REG_DWORD /d 0 /f

# ===================================================================
# STARTUP AND SERVICES OPTIMIZATION
# ===================================================================

Write-Host "Optimizing startup and services..." -ForegroundColor Green

# List of services to disable for better performance
$servicesToDisable = @(
    "Fax",                    # Fax service
    "WMPNetworkSvc",         # Windows Media Player Network Sharing
    "TabletInputService",    # Tablet PC Input Service
    "WSearch",               # Windows Search (already handled above)
    "TrkWks",               # Distributed Link Tracking Client
    "WerSvc",               # Windows Error Reporting
    "DiagTrack",            # Connected User Experiences and Telemetry
    "dmwappushservice",     # WAP Push Message Routing Service
    "MapsBroker",           # Downloaded Maps Manager
    "lfsvc"                 # Geolocation Service
)

foreach ($service in $servicesToDisable) {
    try {
        $serviceObj = Get-Service -Name $service -ErrorAction SilentlyContinue
        if ($serviceObj) {
            Stop-Service -Name $service -Force -ErrorAction SilentlyContinue
            Set-Service -Name $service -StartupType Disabled
            Write-Host "Disabled service: $service" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "Could not disable service: $service" -ForegroundColor Red
    }
}

# ===================================================================
# REGISTRY CLEANUP AND OPTIMIZATION
# ===================================================================

Write-Host "Performing registry optimizations..." -ForegroundColor Green

# Disable Windows Tips and Tricks
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" /v SoftLandingEnabled /t REG_DWORD /d 0 /f
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" /v SystemPaneSuggestionsEnabled /t REG_DWORD /d 0 /f

# Disable consumer features (suggested apps)
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CloudContent" /v DisableWindowsConsumerFeatures /t REG_DWORD /d 1 /f

# Disable Windows Ink workspace
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsInkWorkspace" /v AllowWindowsInkWorkspace /t REG_DWORD /d 0 /f

# Disable People icon in taskbar
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\People" /v PeopleBand /t REG_DWORD /d 0 /f

# Disable Sticky Keys prompt
reg add "HKEY_CURRENT_USER\Control Panel\Accessibility\StickyKeys" /v Flags /t REG_SZ /d "506" /f

# Disable Filter Keys prompt  
reg add "HKEY_CURRENT_USER\Control Panel\Accessibility\Keyboard Response" /v Flags /t REG_SZ /d "122" /f

# Disable Toggle Keys prompt
reg add "HKEY_CURRENT_USER\Control Panel\Accessibility\ToggleKeys" /v Flags /t REG_SZ /d "58" /f

# ===================================================================
# ADDITIONAL SOFTWARE MANAGEMENT
# ===================================================================

Write-Host "Managing additional software..." -ForegroundColor Green

# List of built-in apps to remove (Windows 10/11 bloatware)
$appsToRemove = @(
    "Microsoft.3DBuilder",
    "Microsoft.BingFinance",
    "Microsoft.BingNews", 
    "Microsoft.BingSports",
    "Microsoft.BingWeather",
    "Microsoft.GetHelp",
    "Microsoft.Getstarted",
    "Microsoft.Messaging",
    "Microsoft.Microsoft3DViewer",
    "Microsoft.MicrosoftOfficeHub",
    "Microsoft.MicrosoftSolitaireCollection",
    "Microsoft.NetworkSpeedTest",
    "Microsoft.News",
    "Microsoft.Office.Lens",
    "Microsoft.Office.OneNote",
    "Microsoft.Office.Sway",
    "Microsoft.OneConnect",
    "Microsoft.People",
    "Microsoft.Print3D",
    "Microsoft.RemoteDesktop",
    "Microsoft.SkypeApp",
    "Microsoft.Wallet",
    "Microsoft.Whiteboard",
    "Microsoft.WindowsAlarms",
    "Microsoft.WindowsCamera",
    "microsoft.windowscommunicationsapps",
    "Microsoft.WindowsFeedbackHub",
    "Microsoft.WindowsMaps",
    "Microsoft.WindowsSoundRecorder",
    "Microsoft.Xbox.TCUI",
    "Microsoft.XboxApp",
    "Microsoft.XboxGameOverlay",
    "Microsoft.XboxGamingOverlay",
    "Microsoft.XboxIdentityProvider",
    "Microsoft.XboxSpeechToTextOverlay",
    "Microsoft.ZuneMusic",
    "Microsoft.ZuneVideo"
)

foreach ($app in $appsToRemove) {
    try {
        Get-AppxPackage -Name $app -AllUsers | Remove-AppxPackage -ErrorAction SilentlyContinue
        Get-AppxProvisionedPackage -Online | Where-Object DisplayName -like $app | Remove-AppxProvisionedPackage -Online -ErrorAction SilentlyContinue
        Write-Host "Removed app: $app" -ForegroundColor Yellow
    } catch {
        # Silently continue if app is not found
    }
}

# ===================================================================
# DISK CLEANUP AND MAINTENANCE
# ===================================================================

Write-Host "Performing disk cleanup..." -ForegroundColor Green

# Clean temporary files
Remove-Item -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "$env:LOCALAPPDATA\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue

# Clear Windows Update cache
try {
    Stop-Service wuauserv -Force
    Remove-Item -Path "$env:WINDIR\SoftwareDistribution\Download\*" -Recurse -Force -ErrorAction SilentlyContinue
    Start-Service wuauserv
    Write-Host "Windows Update cache cleared" -ForegroundColor Yellow
} catch {
    Write-Host "Could not clear Windows Update cache" -ForegroundColor Red
}

# Enable Storage Sense (automatic cleanup)
reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy" /v 01 /t REG_DWORD /d 1 /f

# ===================================================================
# CONFIGURATION RESTORE SYSTEM
# ===================================================================

function Get-CurrentlyInstalledApplications {
    Write-Host "Scanning currently installed applications..." -ForegroundColor Cyan
    
    $currentApps = @{}
    
    # Get currently installed software using the same methods as discovery
    try {
        # Registry 64-bit
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg64) {
            $currentApps[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
        
        # Registry 32-bit
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $currentApps.ContainsKey($app.DisplayName)) {
                $currentApps[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
        
        # Store Apps
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            if (-not $currentApps.ContainsKey($app.Name)) {
                $currentApps[$app.Name] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
        
        Write-Host "Found $($currentApps.Count) currently installed applications" -ForegroundColor Green
        return $currentApps
        
    } catch {
        Write-Host "Error scanning installed applications: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Find-AvailableBackups {
    param([string]$BackupBasePath)
    
    Write-Host "Searching for available backups in: $BackupBasePath" -ForegroundColor Cyan
    
    if (!(Test-Path $BackupBasePath)) {
        Write-Host "Backup base path does not exist: $BackupBasePath" -ForegroundColor Red
        return @{}
    }
    
    $availableBackups = @{}
    
    try {
        # Find all backup sessions (timestamp directories)
        $backupSessions = Get-ChildItem $BackupBasePath -Directory | 
            Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "`n💾 BACKUP/RESTORE INFORMATION:" -ForegroundColor Yellow
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    if ($Restore) {
        Write-Host "• Interactive restore: Current configs backed up before restore" -ForegroundColor White
        Write-Host "• Restore logs available in backup base path" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White
Write-Host "Restore configurations: .\script.ps1 -Mode home -Restore" -ForegroundColor White
Write-Host "Restore with custom path: .\script.ps1 -Mode home -Restore -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware -or $Restore) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    if (-not $Restore) {
        Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    }
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
    if ($Restore) {
        Write-Host "Before-restore backups: BackupBasePath\beforeRestoreBackup_YYYY-MM-DD_HH-MM-SS\[AppName]" -ForegroundColor Gray
    }
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan } |
            Sort-Object Name -Descending
        
        foreach ($session in $backupSessions) {
            $sessionPath = $session.FullName
            $sessionName = $session.Name
            
            # Check for StandardSoftwareBackup
            $standardBackupPath = Join-Path $sessionPath "StandardSoftwareBackup\AppData"
            if (Test-Path $standardBackupPath) {
                $standardApps = Get-ChildItem $standardBackupPath -Directory
                foreach ($app in $standardApps) {
                    $appName = $app.Name
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Standard"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
            
            # Check for ComprehensiveSoftwareBackup
            $comprehensiveBackupPath = Join-Path $sessionPath "ComprehensiveSoftwareBackup\Applications"
            if (Test-Path $comprehensiveBackupPath) {
                $comprehensiveApps = Get-ChildItem $comprehensiveBackupPath -Directory
                foreach ($app in $comprehensiveApps) {
                    $appName = $app.Name -replace '_', ' '  # Restore original name format
                    if (-not $availableBackups.ContainsKey($appName)) {
                        $availableBackups[$appName] = @()
                    }
                    $availableBackups[$appName] += @{
                        Session = $sessionName
                        Type = "Comprehensive"
                        Path = $app.FullName
                        BackupDate = $session.CreationTime
                    }
                }
            }
        }
        
        Write-Host "Found backups for $($availableBackups.Count) applications across $($backupSessions.Count) sessions" -ForegroundColor Green
        return $availableBackups
        
    } catch {
        Write-Host "Error searching for backups: $($_.Exception.Message)" -ForegroundColor Red
        return @{}
    }
}

function Backup-CurrentConfiguration {
    param(
        [string]$AppName,
        [string]$RestoreBackupPath,
        [string]$BackupBasePath
    )
    
    try {
        # Create beforeRestore backup directory
        $beforeRestoreTimestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
        $beforeRestorePath = "$BackupBasePath\beforeRestoreBackup_$beforeRestoreTimestamp\$($AppName -replace '[^\w\s-]', '_')"
        New-Item -Path $beforeRestorePath -ItemType Directory -Force | Out-Null
        
        # Get current configuration paths for the application
        $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
        
        $backupSuccess = $false
        
        # Backup current configuration files
        foreach ($configPath in $paths.ConfigPaths) {
            try {
                if (Test-Path $configPath) {
                    $destinationPath = Join-Path $beforeRestorePath (Split-Path $configPath -Leaf)
                    if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                        Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force
                    } else {
                        Copy-Item -Path $configPath -Destination $destinationPath -Force
                    }
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current: $(Split-Path $configPath -Leaf)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup: $configPath" -ForegroundColor Yellow
            }
        }
        
        # Backup current registry keys
        foreach ($regPath in $paths.RegistryPaths) {
            try {
                $regFileName = "$beforeRestorePath\$($AppName -replace '[^\w\s-]', '_')_current_registry.reg"
                reg export "$regPath" "$regFileName" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    $backupSuccess = $true
                    Write-Host "✓ Backed up current registry: $regPath" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "⚠ Failed to backup registry: $regPath" -ForegroundColor Yellow
            }
        }
        
        if ($backupSuccess) {
            # Create metadata file
            $metadata = @{
                AppName = $AppName
                BackupDate = Get-Date
                RestoreSource = $RestoreBackupPath
                Purpose = "BeforeRestore"
            }
            $metadata | ConvertTo-Json | Out-File "$beforeRestorePath\backup_metadata.json" -Encoding UTF8
            
            Write-Host "✅ Current configuration backed up to: $beforeRestorePath" -ForegroundColor Green
            return $beforeRestorePath
        } else {
            Write-Host "⚠ No current configuration found to backup for: $AppName" -ForegroundColor Yellow
            return $null
        }
        
    } catch {
        Write-Host "❌ Failed to backup current configuration: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Restore-ApplicationConfiguration {
    param(
        [string]$AppName,
        [string]$BackupPath,
        [string]$BackupBasePath
    )
    
    Write-Host "`n🔄 RESTORING CONFIGURATION FOR: $AppName" -ForegroundColor Cyan
    Write-Host "From backup: $BackupPath" -ForegroundColor Gray
    
    try {
        # First, backup current configuration
        Write-Host "`n📦 Creating backup of current configuration..." -ForegroundColor Yellow
        $beforeRestoreBackup = Backup-CurrentConfiguration -AppName $AppName -RestoreBackupPath $BackupPath -BackupBasePath $BackupBasePath
        
        $restoreSuccess = $false
        $restoredItems = @()
        
        # Restore configuration files
        Write-Host "`n📂 Restoring configuration files..." -ForegroundColor Yellow
        $configFiles = Get-ChildItem $BackupPath -File | Where-Object { $_.Name -notlike "*.reg" -and $_.Name -ne "backup_metadata.json" }
        
        foreach ($file in $configFiles) {
            try {
                # Try to determine target path based on file name and application
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetFile = Join-Path $parentDir $file.Name
                        Copy-Item -Path $file.FullName -Destination $targetFile -Force
                        Write-Host "✓ Restored: $($file.Name) → $targetFile" -ForegroundColor Green
                        $restoredItems += $targetFile
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for: $($file.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore: $($file.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore configuration directories
        $configDirs = Get-ChildItem $BackupPath -Directory
        foreach ($dir in $configDirs) {
            try {
                $paths = Get-SoftwareConfigPaths -SoftwareName $AppName -Publisher "" -InstallLocation ""
                
                $restored = $false
                foreach ($targetPath in $paths.ConfigPaths) {
                    $parentDir = Split-Path $targetPath -Parent
                    if (Test-Path $parentDir) {
                        $targetDir = Join-Path $parentDir $dir.Name
                        Copy-Item -Path $dir.FullName -Destination $targetDir -Recurse -Force
                        Write-Host "✓ Restored directory: $($dir.Name) → $targetDir" -ForegroundColor Green
                        $restoredItems += $targetDir
                        $restoreSuccess = $true
                        $restored = $true
                        break
                    }
                }
                
                if (-not $restored) {
                    Write-Host "⚠ Could not determine target for directory: $($dir.Name)" -ForegroundColor Yellow
                }
                
            } catch {
                Write-Host "✗ Failed to restore directory: $($dir.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Restore registry entries
        Write-Host "`n🔧 Restoring registry entries..." -ForegroundColor Yellow
        $regFiles = Get-ChildItem $BackupPath -Filter "*.reg"
        
        foreach ($regFile in $regFiles) {
            try {
                Write-Host "Importing registry: $($regFile.Name)" -ForegroundColor Cyan
                reg import "$($regFile.FullName)" /reg:64
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Registry imported: $($regFile.Name)" -ForegroundColor Green
                    $restoredItems += $regFile.FullName
                    $restoreSuccess = $true
                } else {
                    Write-Host "✗ Registry import failed: $($regFile.Name)" -ForegroundColor Red
                }
            } catch {
                Write-Host "✗ Registry import error: $($regFile.Name) - $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        # Create restore log
        if ($restoreSuccess) {
            $restoreLog = @{
                AppName = $AppName
                RestoreDate = Get-Date
                SourceBackup = $BackupPath
                BeforeRestoreBackup = $beforeRestoreBackup
                RestoredItems = $restoredItems
                Status = "Success"
            }
            
            $logPath = "$BackupBasePath\restore_log_$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss').json"
            $restoreLog | ConvertTo-Json -Depth 3 | Out-File $logPath -Encoding UTF8
            
            Write-Host "`n✅ RESTORE COMPLETED SUCCESSFULLY" -ForegroundColor Green
            Write-Host "Restored items: $($restoredItems.Count)" -ForegroundColor White
            Write-Host "Restore log: $logPath" -ForegroundColor White
            if ($beforeRestoreBackup) {
                Write-Host "Current config backed up to: $beforeRestoreBackup" -ForegroundColor White
            }
            
            return $true
        } else {
            Write-Host "`n❌ RESTORE FAILED - No items were successfully restored" -ForegroundColor Red
            return $false
        }
        
    } catch {
        Write-Host "`n❌ RESTORE ERROR: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

function Start-ConfigurationRestore {
    param([string]$BackupBasePath)
    
    Write-Host "`n🔄 CONFIGURATION RESTORE MODE" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    
    # Get currently installed applications
    $currentApps = Get-CurrentlyInstalledApplications
    if ($currentApps.Count -eq 0) {
        Write-Host "No installed applications found. Cannot proceed with restore." -ForegroundColor Red
        return
    }
    
    # Find available backups
    $availableBackups = Find-AvailableBackups -BackupBasePath $BackupBasePath
    if ($availableBackups.Count -eq 0) {
        Write-Host "No configuration backups found in: $BackupBasePath" -ForegroundColor Red
        return
    }
    
    # Find applications that are both installed and have backups
    $restorableApps = @{}
    foreach ($appName in $availableBackups.Keys) {
        # Try to match app names (exact match or partial match)
        $matchingApp = $null
        foreach ($installedApp in $currentApps.Keys) {
            if ($installedApp -eq $appName -or 
                $installedApp -like "*$appName*" -or 
                $appName -like "*$installedApp*") {
                $matchingApp = $installedApp
                break
            }
        }
        
        if ($matchingApp) {
            $restorableApps[$appName] = @{
                InstalledName = $matchingApp
                Backups = $availableBackups[$appName]
            }
        }
    }
    
    if ($restorableApps.Count -eq 0) {
        Write-Host "No restorable applications found." -ForegroundColor Yellow
        Write-Host "This means no installed applications have available configuration backups." -ForegroundColor Yellow
        return
    }
    
    Write-Host "`n📋 RESTORABLE APPLICATIONS:" -ForegroundColor Green
    Write-Host "Found $($restorableApps.Count) applications with available backups" -ForegroundColor White
    
    # Display restorable applications
    $appIndex = 1
    $appList = @()
    foreach ($app in $restorableApps.GetEnumerator()) {
        $appList += $app
        Write-Host "$appIndex. $($app.Key) ($($app.Value.Backups.Count) backup(s) available)" -ForegroundColor Cyan
        $appIndex++
    }
    
    # Application selection loop
    do {
        Write-Host "`n🎯 SELECT APPLICATION TO RESTORE:" -ForegroundColor Yellow
        Write-Host "Enter application number (1-$($appList.Count)) or 'q' to quit: " -NoNewline
        $selection = Read-Host
        
        if ($selection -eq 'q' -or $selection -eq 'Q') {
            Write-Host "Restore cancelled by user." -ForegroundColor Yellow
            return
        }
        
        if ($selection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$selection -ge 1 -and [int]$selection -le $appList.Count) {
            $selectedApp = $appList[[int]$selection - 1]
            $appName = $selectedApp.Key
            $appBackups = $selectedApp.Value.Backups
            
            Write-Host "`n📦 AVAILABLE BACKUPS FOR: $appName" -ForegroundColor Cyan
            
            # Display available backups
            $backupIndex = 1
            foreach ($backup in $appBackups) {
                Write-Host "$backupIndex. Session: $($backup.Session) | Type: $($backup.Type) | Date: $($backup.BackupDate)" -ForegroundColor White
                $backupIndex++
            }
            
            # Backup selection
            Write-Host "`nSelect backup number (1-$($appBackups.Count)) or 'b' to go back: " -NoNewline
            $backupSelection = Read-Host
            
            if ($backupSelection -eq 'b' -or $backupSelection -eq 'B') {
                continue  # Go back to app selection
            }
            
            if ($backupSelection -match '^\d+

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan -and [int]$backupSelection -ge 1 -and [int]$backupSelection -le $appBackups.Count) {
                $selectedBackup = $appBackups[[int]$backupSelection - 1]
                
                Write-Host "`n⚠️  CONFIRMATION REQUIRED" -ForegroundColor Yellow
                Write-Host "You are about to restore configuration for: $appName" -ForegroundColor White
                Write-Host "From backup: $($selectedBackup.Session) ($($selectedBackup.Type))" -ForegroundColor White
                Write-Host "Current configuration will be backed up before restore." -ForegroundColor White
                Write-Host "`nProceed with restore? (y/n): " -NoNewline
                $confirm = Read-Host
                
                if ($confirm -eq 'y' -or $confirm -eq 'Y' -or $confirm -eq 'yes') {
                    $restoreResult = Restore-ApplicationConfiguration -AppName $appName -BackupPath $selectedBackup.Path -BackupBasePath $BackupBasePath
                    
                    if ($restoreResult) {
                        Write-Host "`n🎉 Configuration restored successfully!" -ForegroundColor Green
                        Write-Host "You may need to restart the application to see changes." -ForegroundColor Yellow
                    } else {
                        Write-Host "`n💥 Configuration restore failed!" -ForegroundColor Red
                    }
                    
                    Write-Host "`nRestore another application? (y/n): " -NoNewline
                    $continueRestore = Read-Host
                    if ($continueRestore -ne 'y' -and $continueRestore -ne 'Y' -and $continueRestore -ne 'yes') {
                        break
                    }
                } else {
                    Write-Host "Restore cancelled." -ForegroundColor Yellow
                }
            } else {
                Write-Host "Invalid backup selection." -ForegroundColor Red
            }
        } else {
            Write-Host "Invalid application selection." -ForegroundColor Red
        }
    } while ($true)
    
    Write-Host "`n✅ RESTORE SESSION COMPLETED" -ForegroundColor Green
}

function Get-AllInstalledSoftware {
    Write-Host "Discovering all installed software..." -ForegroundColor Cyan
    
    $installedSoftware = @{}
    
    # Method 1: Registry - Uninstall entries (64-bit)
    try {
        $reg64 = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg64) {
            $installedSoftware[$app.DisplayName] = @{
                Publisher = $app.Publisher
                InstallLocation = $app.InstallLocation
                UninstallString = $app.UninstallString
                Version = $app.DisplayVersion
                Source = "Registry64"
            }
        }
    } catch {
        Write-Host "Could not read 64-bit registry" -ForegroundColor Yellow
    }
    
    # Method 2: Registry - Uninstall entries (32-bit on 64-bit systems)
    try {
        $reg32 = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue |
            Where-Object { $_.DisplayName -and $_.DisplayName -ne "" } |
            Select-Object DisplayName, Publisher, InstallLocation, UninstallString, DisplayVersion
        
        foreach ($app in $reg32) {
            if (-not $installedSoftware.ContainsKey($app.DisplayName)) {
                $installedSoftware[$app.DisplayName] = @{
                    Publisher = $app.Publisher
                    InstallLocation = $app.InstallLocation
                    UninstallString = $app.UninstallString
                    Version = $app.DisplayVersion
                    Source = "Registry32"
                }
            }
        }
    } catch {
        Write-Host "Could not read 32-bit registry" -ForegroundColor Yellow
    }
    
    # Method 3: Windows Store Apps (UWP)
    try {
        $storeApps = Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "Microsoft.Windows*" -and $_.Name -notlike "*Framework*" } |
            Select-Object Name, PackageFullName, InstallLocation, Version
        
        foreach ($app in $storeApps) {
            $displayName = $app.Name
            if (-not $installedSoftware.ContainsKey($displayName)) {
                $installedSoftware[$displayName] = @{
                    Publisher = "Microsoft Store"
                    InstallLocation = $app.InstallLocation
                    UninstallString = "Remove-AppxPackage $($app.PackageFullName)"
                    Version = $app.Version
                    Source = "StoreApp"
                }
            }
        }
    } catch {
        Write-Host "Could not read Store apps" -ForegroundColor Yellow
    }
    
    # Method 4: Chocolatey packages
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        try {
            $chocoOutput = choco list --local-only --limit-output
            foreach ($line in $chocoOutput) {
                if ($line -and $line.Contains("|")) {
                    $parts = $line.Split("|")
                    $packageName = $parts[0]
                    $version = $parts[1]
                    
                    if (-not $installedSoftware.ContainsKey($packageName)) {
                        $installedSoftware[$packageName] = @{
                            Publisher = "Chocolatey"
                            InstallLocation = "Chocolatey Managed"
                            UninstallString = "choco uninstall $packageName"
                            Version = $version
                            Source = "Chocolatey"
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Chocolatey packages" -ForegroundColor Yellow
        }
    }
    
    # Method 5: Winget packages
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            foreach ($line in $wingetOutput) {
                if ($line -and $line.Trim() -and -not $line.StartsWith("Name") -and -not $line.StartsWith("---")) {
                    # Parse winget output (format can vary)
                    $parts = $line -split '\s{2,}' # Split on multiple spaces
                    if ($parts.Length -ge 2) {
                        $packageName = $parts[0].Trim()
                        $version = if ($parts.Length -ge 3) { $parts[2].Trim() } else { "Unknown" }
                        
                        if ($packageName -and -not $installedSoftware.ContainsKey($packageName)) {
                            $installedSoftware[$packageName] = @{
                                Publisher = "Winget"
                                InstallLocation = "Winget Managed"
                                UninstallString = "winget uninstall `"$packageName`""
                                Version = $version
                                Source = "Winget"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "Could not read Winget packages" -ForegroundColor Yellow
        }
    }
    
    Write-Host "Found $($installedSoftware.Count) installed applications" -ForegroundColor Green
    return $installedSoftware
}

function Get-SoftwareConfigPaths {
    param([string]$SoftwareName, [string]$Publisher, [string]$InstallLocation)
    
    $configPaths = @()
    $registryPaths = @()
    
    # Normalize software name for pattern matching
    $normalizedName = $SoftwareName -replace '[^\w\s]', '' -replace '\s+', ' '
    $nameWords = $normalizedName.Split(' ')
    $primaryWord = $nameWords[0]
    
    # Common configuration file patterns
    $commonPaths = @(
        # AppData patterns
        "$env:APPDATA\$SoftwareName",
        "$env:APPDATA\$primaryWord",
        "$env:LOCALAPPDATA\$SoftwareName",
        "$env:LOCALAPPDATA\$primaryWord",
        "$env:APPDATA\$Publisher\$SoftwareName",
        "$env:LOCALAPPDATA\$Publisher\$SoftwareName",
        
        # User profile patterns
        "$env:USERPROFILE\.$SoftwareName",
        "$env:USERPROFILE\.$($primaryWord.ToLower())",
        "$env:USERPROFILE\.config\$SoftwareName",
        "$env:USERPROFILE\.config\$primaryWord",
        
        # Documents patterns
        "$env:USERPROFILE\Documents\$SoftwareName",
        "$env:USERPROFILE\Documents\$primaryWord",
        
        # Program Files patterns (if install location known)
        $(if ($InstallLocation) { "$InstallLocation\config" }),
        $(if ($InstallLocation) { "$InstallLocation\settings" }),
        $(if ($InstallLocation) { "$InstallLocation\data" })
    )
    
    # Registry patterns
    $registryPatterns = @(
        "HKEY_CURRENT_USER\SOFTWARE\$SoftwareName",
        "HKEY_CURRENT_USER\SOFTWARE\$primaryWord",
        "HKEY_CURRENT_USER\SOFTWARE\$Publisher\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$SoftwareName",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$primaryWord",
        "HKEY_LOCAL_MACHINE\SOFTWARE\$Publisher\$SoftwareName"
    )
    
    # Check which paths actually exist
    foreach ($path in $commonPaths) {
        if ($path -and (Test-Path $path)) {
            $configPaths += $path
        }
    }
    
    # Check registry paths
    foreach ($regPath in $registryPatterns) {
        if ($regPath) {
            try {
                $testPath = $regPath -replace 'HKEY_CURRENT_USER', 'HKCU:' -replace 'HKEY_LOCAL_MACHINE', 'HKLM:'
                if (Test-Path $testPath) {
                    $registryPaths += $regPath
                }
            } catch {
                # Ignore registry access errors
            }
        }
    }
    
    return @{
        ConfigPaths = $configPaths
        RegistryPaths = $registryPaths
    }
}

function Backup-AllInstalledSoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\ComprehensiveSoftwareBackup"
    )
    
    Write-Host "`n--- COMPREHENSIVE SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating comprehensive backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories with standardized structure
        $subDirs = @("Applications", "Registry", "AppData", "SystemConfig", "Reports")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        # Discover all installed software
        $installedSoftware = Get-AllInstalledSoftware
        
        # Export discovered software list
        $installedSoftware | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\Reports\DiscoveredSoftware.json" -Encoding UTF8
        
        # Create CSV report of discovered software
        $softwareReport = @()
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $softwareReport += [PSCustomObject]@{
                Name = $app.Key
                Publisher = $app.Value.Publisher
                Version = $app.Value.Version
                InstallLocation = $app.Value.InstallLocation
                Source = $app.Value.Source
            }
        }
        $softwareReport | Export-Csv "$BackupPath\Reports\DiscoveredSoftware.csv" -NoTypeInformation
        
        Write-Host "Software discovery completed. Processing configurations..." -ForegroundColor Yellow
        
        $backupStats = @{
            TotalApps = $installedSoftware.Count
            ConfigsFound = 0
            RegistryKeys = 0
            FilesBackedUp = 0
            Errors = 0
        }
        
        $configReport = @()
        
        # Process each discovered application
        $counter = 0
        foreach ($app in $installedSoftware.GetEnumerator()) {
            $counter++
            $softwareName = $app.Key
            $appInfo = $app.Value
            
            Write-Progress -Activity "Backing up software configurations" -Status "Processing: $softwareName" -PercentComplete (($counter / $installedSoftware.Count) * 100)
            
            try {
                # Get potential configuration paths
                $paths = Get-SoftwareConfigPaths -SoftwareName $softwareName -Publisher $appInfo.Publisher -InstallLocation $appInfo.InstallLocation
                
                $appBackupPath = "$BackupPath\DiscoveredApps\$($softwareName -replace '[^\w\s-]', '_')"
                
                $appReport = [PSCustomObject]@{
                    SoftwareName = $softwareName
                    Publisher = $appInfo.Publisher
                    Version = $appInfo.Version
                    Source = $appInfo.Source
                    ConfigPathsFound = $paths.ConfigPaths.Count
                    RegistryPathsFound = $paths.RegistryPaths.Count
                    BackupStatus = "Success"
                    ErrorMessage = ""
                }
                
                if ($paths.ConfigPaths.Count -gt 0 -or $paths.RegistryPaths.Count -gt 0) {
                    New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
                    $backupStats.ConfigsFound++
                    
                    # Backup configuration files
                    foreach ($configPath in $paths.ConfigPaths) {
                        try {
                            $destinationPath = Join-Path $appBackupPath (Split-Path $configPath -Leaf)
                            if ((Get-Item $configPath) -is [System.IO.DirectoryInfo]) {
                                Copy-Item -Path $configPath -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                            } else {
                                Copy-Item -Path $configPath -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                            }
                            $backupStats.FilesBackedUp++
                        } catch {
                            $appReport.ErrorMessage += "File backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    # Backup registry keys
                    foreach ($regPath in $paths.RegistryPaths) {
                        try {
                            $regFileName = "$appBackupPath\$($softwareName -replace '[^\w\s-]', '_')_registry.reg"
                            reg export "$regPath" "$regFileName" /y 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $backupStats.RegistryKeys++
                            }
                        } catch {
                            $appReport.ErrorMessage += "Registry backup error: $($_.Exception.Message); "
                        }
                    }
                    
                    Write-Host "✓ $softwareName ($($paths.ConfigPaths.Count) paths, $($paths.RegistryPaths.Count) reg keys)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ $softwareName (no config paths found)" -ForegroundColor Yellow
                }
                
                $configReport += $appReport
                
            } catch {
                $backupStats.Errors++
                $appReport.BackupStatus = "Error"
                $appReport.ErrorMessage = $_.Exception.Message
                $configReport += $appReport
                Write-Host "✗ $softwareName - Error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        Write-Progress -Activity "Backing up software configurations" -Completed
        
        # Export detailed configuration report
        $configReport | Export-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv" -NoTypeInformation
        
        # Create comprehensive restoration script
        $restoreScript = @"
# Comprehensive Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Comprehensive Software Configuration Restoration" -ForegroundColor Cyan
Write-Host "===============================================" -ForegroundColor Cyan

# Load backup reports
`$discoveredSoftware = Get-Content "$BackupPath\Reports\DiscoveredSoftware.json" | ConvertFrom-Json
`$configReport = Import-Csv "$BackupPath\Reports\ConfigurationBackupReport.csv"

Write-Host "Discovered software with configurations: `$(`$configReport.Count)" -ForegroundColor Yellow

# Registry restoration
Write-Host "`nRestoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Recurse -Filter "*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# Configuration files restoration guide
Write-Host "`nConfiguration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Applications" -Directory | ForEach-Object {
    Write-Host "Application: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
    Get-ChildItem `$_.FullName -File | ForEach-Object {
        Write-Host "  - `$(`$_.Name)" -ForegroundColor White
    }
    Write-Host ""
}

Write-Host "Manual restoration may be required for some applications." -ForegroundColor Yellow
Write-Host "Check the ConfigurationBackupReport.csv for detailed information." -ForegroundColor Yellow
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create comprehensive backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = "AllInstalledSoftware"
            "Statistics" = $backupStats
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json -Depth 3 | Out-File "$BackupPath\COMPREHENSIVE_BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ COMPREHENSIVE SOFTWARE BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total applications discovered: $($backupStats.TotalApps)" -ForegroundColor White
        Write-Host "Applications with configurations: $($backupStats.ConfigsFound)" -ForegroundColor White
        Write-Host "Registry keys backed up: $($backupStats.RegistryKeys)" -ForegroundColor White
        Write-Host "Files backed up: $($backupStats.FilesBackedUp)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Detailed report: $BackupPath\Reports\ConfigurationBackupReport.csv" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_ALL_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ COMPREHENSIVE BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Backup-SoftwareConfigurations {
    param(
        [string]$BackupPath = "$StandardBackupPath\StandardSoftwareBackup"
    )
    
    Write-Host "`n--- SOFTWARE CONFIGURATION BACKUP ---" -ForegroundColor Cyan
    Write-Host "Creating backup at: $BackupPath" -ForegroundColor Green
    
    try {
        # Create main backup directory
        New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        
        # Create subdirectories
        $subDirs = @("Registry", "AppData", "ProgramData", "UserProfiles", "SystemConfig", "BrowserData", "IDEConfigs")
        foreach ($dir in $subDirs) {
            New-Item -Path "$BackupPath\$dir" -ItemType Directory -Force | Out-Null
        }
        
        Write-Host "Backup directories created successfully" -ForegroundColor Green
        
        # ===================================================================
        # REGISTRY BACKUPS
        # ===================================================================
        Write-Host "`nBacking up registry configurations..." -ForegroundColor Yellow
        
        $registryKeys = @{
            "HKCU_Software" = "HKEY_CURRENT_USER\Software"
            "HKLM_Software" = "HKEY_LOCAL_MACHINE\SOFTWARE"
            "HKCU_AppData" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
            "WindowsTerminal" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            "PowerToys" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\PowerToys"
            "VSCode" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\VSCode"
            "Chrome" = "HKEY_CURRENT_USER\SOFTWARE\Google\Chrome"
            "Firefox" = "HKEY_CURRENT_USER\SOFTWARE\Mozilla"
            "Bitwarden" = "HKEY_CURRENT_USER\SOFTWARE\Bitwarden"
            "Docker" = "HKEY_CURRENT_USER\SOFTWARE\Docker Inc."
            "Git" = "HKEY_CURRENT_USER\SOFTWARE\GitForWindows"
            "PuTTY" = "HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY"
            "WinSCP" = "HKEY_CURRENT_USER\SOFTWARE\Martin Prikryl\WinSCP 2"
            "Notepad++" = "HKEY_CURRENT_USER\SOFTWARE\Notepad++"
            "7Zip" = "HKEY_CURRENT_USER\SOFTWARE\7-Zip"
            "VLC" = "HKEY_CURRENT_USER\SOFTWARE\VideoLAN\VLC"
            "WhatsApp" = "HKEY_CURRENT_USER\SOFTWARE\WhatsApp"
            "Office" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office"
            "WindowsSettings" = "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes"
        }
        
        foreach ($key in $registryKeys.GetEnumerator()) {
            try {
                $regFile = "$BackupPath\Registry\$($key.Key).reg"
                reg export "$($key.Value)" "$regFile" /y 2>$null
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✓ Exported: $($key.Key)" -ForegroundColor Green
                } else {
                    Write-Host "⚠ Skipped: $($key.Key) (not found)" -ForegroundColor Yellow
                }
            } catch {
                Write-Host "✗ Failed: $($key.Key)" -ForegroundColor Red
            }
        }
        
        # ===================================================================
        # APPLICATION DATA BACKUPS
        # ===================================================================
        Write-Host "`nBacking up application data..." -ForegroundColor Yellow
        
        $appDataPaths = @{
            # Development Tools
            "VSCode" = @(
                "$env:APPDATA\Code\User\settings.json",
                "$env:APPDATA\Code\User\keybindings.json",
                "$env:APPDATA\Code\User\snippets",
                "$env:APPDATA\Code\User\extensions"
            )
            "Git" = @(
                "$env:USERPROFILE\.gitconfig",
                "$env:USERPROFILE\.gitignore_global",
                "$env:USERPROFILE\.ssh"
            )
            "PowerShell" = @(
                "$env:USERPROFILE\Documents\PowerShell",
                "$env:USERPROFILE\Documents\WindowsPowerShell",
                "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine"
            )
            "WindowsTerminal" = @(
                "$env:LOCALAPPDATA\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json",
                "$env:APPDATA\Microsoft\Windows\Terminal"
            )
            
            # Browsers
            "Chrome" = @(
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Preferences",
                "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions"
            )
            "Firefox" = @(
                "$env:APPDATA\Mozilla\Firefox\Profiles"
            )
            "Edge" = @(
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks",
                "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Preferences"
            )
            
            # Communication
            "WhatsApp" = @(
                "$env:LOCALAPPDATA\WhatsApp"
            )
            "Messenger" = @(
                "$env:LOCALAPPDATA\Facebook\Messenger"
            )
            
            # Security
            "Bitwarden" = @(
                "$env:APPDATA\Bitwarden"
            )
            
            # Network Tools
            "PuTTY" = @(
                "$env:APPDATA\PuTTY",
                "$env:USERPROFILE\.putty"
            )
            "WinSCP" = @(
                "$env:APPDATA\WinSCP.ini"
            )
            "Wireshark" = @(
                "$env:APPDATA\Wireshark"
            )
            
            # Text Editors
            "Notepad++" = @(
                "$env:APPDATA\Notepad++\config.xml",
                "$env:APPDATA\Notepad++\shortcuts.xml",
                "$env:APPDATA\Notepad++\stylers.xml",
                "$env:APPDATA\Notepad++\themes"
            )
            
            # Media Players
            "VLC" = @(
                "$env:APPDATA\vlc\vlcrc",
                "$env:APPDATA\vlc\ml.xspf"
            )
            "PotPlayer" = @(
                "$env:APPDATA\PotPlayerMini64",
                "$env:APPDATA\PotPlayer64"
            )
            
            # Office & Productivity
            "Office365" = @(
                "$env:APPDATA\Microsoft\Templates",
                "$env:APPDATA\Microsoft\Word",
                "$env:APPDATA\Microsoft\Excel",
                "$env:APPDATA\Microsoft\PowerPoint",
                "$env:APPDATA\Microsoft\Outlook"
            )
            "OneNote" = @(
                "$env:LOCALAPPDATA\Microsoft\OneNote"
            )
            
            # Development Environments
            "JetBrains" = @(
                "$env:APPDATA\JetBrains",
                "$env:LOCALAPPDATA\JetBrains"
            )
            "Python" = @(
                "$env:APPDATA\Python",
                "$env:USERPROFILE\.conda",
                "$env:USERPROFILE\.jupyter"
            )
            "Docker" = @(
                "$env:APPDATA\Docker",
                "$env:USERPROFILE\.docker"
            )
            
            # Cloud CLI Tools
            "Azure" = @(
                "$env:USERPROFILE\.azure"
            )
            "AWS" = @(
                "$env:USERPROFILE\.aws"
            )
            "GoogleCloud" = @(
                "$env:APPDATA\gcloud"
            )
            
            # System Tools
            "PowerToys" = @(
                "$env:LOCALAPPDATA\Microsoft\PowerToys"
            )
            "Sysinternals" = @(
                "$env:USERPROFILE\Documents\Sysinternals"
            )
            
            # Archive Tools
            "7Zip" = @(
                "$env:APPDATA\7-Zip"
            )
            
            # AI/LLM Tools
            "Ollama" = @(
                "$env:USERPROFILE\.ollama"
            )
            "LMStudio" = @(
                "$env:LOCALAPPDATA\LM Studio"
            )
            "Anaconda" = @(
                "$env:USERPROFILE\.condarc",
                "$env:USERPROFILE\anaconda3\envs"
            )
        }
        
        foreach ($app in $appDataPaths.GetEnumerator()) {
            Write-Host "Backing up $($app.Key) configurations..." -ForegroundColor Cyan
            $appBackupPath = "$BackupPath\AppData\$($app.Key)"
            New-Item -Path $appBackupPath -ItemType Directory -Force | Out-Null
            
            foreach ($path in $app.Value) {
                try {
                    if (Test-Path $path) {
                        $destinationPath = Join-Path $appBackupPath (Split-Path $path -Leaf)
                        if ((Get-Item $path) -is [System.IO.DirectoryInfo]) {
                            Copy-Item -Path $path -Destination $destinationPath -Recurse -Force
                        } else {
                            Copy-Item -Path $path -Destination $destinationPath -Force
                        }
                        Write-Host "✓ Backed up: $(Split-Path $path -Leaf)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠ Not found: $path" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "✗ Failed to backup: $path - $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        }
        
        # ===================================================================
        # SYSTEM CONFIGURATION BACKUPS
        # ===================================================================
        Write-Host "`nBacking up system configurations..." -ForegroundColor Yellow
        
        $systemConfigs = @{
            "Hosts" = "C:\Windows\System32\drivers\etc\hosts"
            "Networks" = "C:\Windows\System32\drivers\etc\networks"
            "Services" = "C:\Windows\System32\drivers\etc\services"
            "StartupPrograms" = "Get-CimInstance Win32_StartupCommand"
            "InstalledPrograms" = "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
            "EnvironmentVariables" = "Get-ChildItem Env:"
            "WindowsFeatures" = "Get-WindowsOptionalFeature -Online"
            "Firewall" = "netsh advfirewall export"
            "NetworkProfiles" = "netsh wlan export profile folder="
        }
        
        # Export hosts file
        try {
            Copy-Item "C:\Windows\System32\drivers\etc\hosts" "$BackupPath\SystemConfig\hosts.backup" -Force
            Write-Host "✓ Backed up: hosts file" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup hosts file" -ForegroundColor Red
        }
        
        # Export installed programs list
        try {
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                Export-Csv "$BackupPath\SystemConfig\InstalledPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Installed programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup installed programs list" -ForegroundColor Red
        }
        
        # Export startup programs
        try {
            Get-CimInstance Win32_StartupCommand | 
                Select-Object Name, Command, Location, User | 
                Export-Csv "$BackupPath\SystemConfig\StartupPrograms.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Startup programs list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup startup programs list" -ForegroundColor Red
        }
        
        # Export environment variables
        try {
            Get-ChildItem Env: | 
                Export-Csv "$BackupPath\SystemConfig\EnvironmentVariables.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Environment variables" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup environment variables" -ForegroundColor Red
        }
        
        # Export Windows features
        try {
            Get-WindowsOptionalFeature -Online | 
                Where-Object State -eq "Enabled" | 
                Export-Csv "$BackupPath\SystemConfig\EnabledWindowsFeatures.csv" -NoTypeInformation
            Write-Host "✓ Backed up: Windows features list" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup Windows features list" -ForegroundColor Red
        }
        
        # Export firewall settings
        try {
            netsh advfirewall export "$BackupPath\SystemConfig\firewall.wfw"
            Write-Host "✓ Backed up: Firewall settings" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup firewall settings" -ForegroundColor Red
        }
        
        # Export WiFi profiles
        try {
            netsh wlan export profile folder="$BackupPath\SystemConfig\" key=clear
            Write-Host "✓ Backed up: WiFi profiles" -ForegroundColor Green
        } catch {
            Write-Host "✗ Failed to backup WiFi profiles" -ForegroundColor Red
        }
        
        # ===================================================================
        # CREATE RESTORATION SCRIPT
        # ===================================================================
        Write-Host "`nCreating restoration script..." -ForegroundColor Yellow
        
        $restoreScript = @"
# Software Configuration Restoration Script
# Generated on: $(Get-Date)
# Backup Location: $BackupPath

Write-Host "Software Configuration Restoration Script" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan

# Registry Restoration
Write-Host "Restoring registry configurations..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\Registry\*.reg" | ForEach-Object {
    try {
        Write-Host "Importing: `$(`$_.Name)" -ForegroundColor Cyan
        reg import "`$(`$_.FullName)" /reg:64
        if (`$LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully imported: `$(`$_.Name)" -ForegroundColor Green
        } else {
            Write-Host "✗ Failed to import: `$(`$_.Name)" -ForegroundColor Red
        }
    } catch {
        Write-Host "✗ Error importing `$(`$_.Name): `$(`$_.Exception.Message)" -ForegroundColor Red
    }
}

# AppData Restoration
Write-Host "`nRestoring application data..." -ForegroundColor Yellow
Get-ChildItem "$BackupPath\AppData" -Directory | ForEach-Object {
    Write-Host "Available for manual restoration: `$(`$_.Name)" -ForegroundColor Cyan
    Write-Host "Location: `$(`$_.FullName)" -ForegroundColor Gray
}

# System Configuration Restoration
Write-Host "`nSystem configuration files available for restoration:" -ForegroundColor Yellow
Get-ChildItem "$BackupPath\SystemConfig" | ForEach-Object {
    Write-Host "- `$(`$_.Name)" -ForegroundColor Gray
}

Write-Host "`nRestoration completed. Please restart applications to apply changes." -ForegroundColor Green
"@
        
        $restoreScript | Out-File "$BackupPath\RESTORE_CONFIGURATIONS.ps1" -Encoding UTF8
        
        # Create backup manifest
        $manifest = @{
            "BackupDate" = Get-Date
            "BackupPath" = $BackupPath
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "BackupMode" = $Mode
            "TotalFiles" = (Get-ChildItem $BackupPath -Recurse -File).Count
            "BackupSize" = [math]::Round(((Get-ChildItem $BackupPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB), 2)
        }
        
        $manifest | ConvertTo-Json | Out-File "$BackupPath\BACKUP_MANIFEST.json" -Encoding UTF8
        
        Write-Host "`n✅ SOFTWARE CONFIGURATION BACKUP COMPLETED" -ForegroundColor Green
        Write-Host "Backup location: $BackupPath" -ForegroundColor White
        Write-Host "Total files backed up: $($manifest.TotalFiles)" -ForegroundColor White
        Write-Host "Backup size: $($manifest.BackupSize) MB" -ForegroundColor White
        Write-Host "Restoration script: $BackupPath\RESTORE_CONFIGURATIONS.ps1" -ForegroundColor White
        
        return $BackupPath
        
    } catch {
        Write-Host "❌ BACKUP FAILED: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

Write-Host "Configuring Start Menu layout..." -ForegroundColor Green

# Create Start Menu layout XML configuration
$startLayoutXML = @"
<?xml version="1.0" encoding="utf-8"?>
<LayoutModificationTemplate 
    xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification"
    xmlns:defaultlayout="http://schemas.microsoft.com/Start/2014/FullDefaultLayout"
    xmlns:start="http://schemas.microsoft.com/Start/2014/StartLayout"
    Version="1">
  <LayoutOptions StartTileGroupCellWidth="6" />
  <DefaultLayoutOverride>
    <StartLayoutCollection>
      <defaultlayout:StartLayout GroupCellWidth="6">
        
        <!-- SYSTEM ADMINISTRATION GROUP -->
        <start:Group Name="System Administration">
          <start:Tile Size="2x2" Column="0" Row="0" AppUserModelID="windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel" />
          <start:Tile Size="2x2" Column="2" Row="0" AppUserModelID="Microsoft.WindowsTerminal_8wekyb3d8bbwe!App" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.PowerToys_8wekyb3d8bbwe!PowerToys" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Windows.Explorer" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Microsoft.TaskManager" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Microsoft.SystemInformation" />
        </start:Group>

        <!-- DEVELOPMENT TOOLS GROUP -->
        <start:Group Name="Development Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Microsoft.VisualStudioCode.exe" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Git.Git" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Python.Python.3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Docker.DockerDesktop" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="JetBrains.Toolbox" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Notepad++.Notepad++" />
        </start:Group>

        <!-- WEB & COMMUNICATION GROUP -->
        <start:Group Name="Web & Communication">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Google.Chrome" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="Mozilla.Firefox" />
          <start:Tile Size="2x2" Column="4" Row="0" AppUserModelID="Microsoft.Office.OneNote_8wekyb3d8bbwe!microsoft.onenoteim" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="WhatsApp.WhatsApp" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Facebook.Messenger" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Postman.Postman" />
        </start:Group>

        <!-- SECURITY & NETWORK GROUP -->
        <start:Group Name="Security & Network">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Bitwarden.Bitwarden" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="WiresharkFoundation.Wireshark" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="OpenVPNTechnologies.OpenVPNConnect" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="PuTTY.PuTTY" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="WinSCP.WinSCP" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Insecure.Nmap" />
        </start:Group>

        <!-- PRODUCTIVITY & OFFICE GROUP -->
        <start:Group Name="Productivity & Office">
          <start:DesktopApplicationTile Size="4x2" Column="0" Row="0" DesktopApplicationID="Microsoft.Office.WINWORD.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Microsoft.Office.EXCEL.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.Office.POWERPNT.EXE.15" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="7zip.7zip" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="voidtools.Everything" />
        </start:Group>

        <!-- AI & CLOUD TOOLS GROUP -->
        <start:Group Name="AI & Cloud Tools">
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="0" DesktopApplicationID="Ollama.Ollama" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="0" DesktopApplicationID="LMStudio.LMStudio" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="0" DesktopApplicationID="Anaconda.Anaconda3" />
          <start:DesktopApplicationTile Size="2x2" Column="0" Row="2" DesktopApplicationID="Microsoft.AzureCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="2" Row="2" DesktopApplicationID="Amazon.AWSCLI" />
          <start:DesktopApplicationTile Size="2x2" Column="4" Row="2" DesktopApplicationID="Hashicorp.Terraform" />
        </start:Group>

      </defaultlayout:StartLayout>
    </StartLayoutCollection>
  </DefaultLayoutOverride>
</LayoutModificationTemplate>
"@

# Function to configure Start Menu layout
function Set-StartMenuLayout {
    try {
        # Create temporary layout file
        $layoutPath = "$env:TEMP\StartMenuLayout.xml"
        $startLayoutXML | Out-File -FilePath $layoutPath -Encoding UTF8
        
        Write-Host "Applying Start Menu layout..." -ForegroundColor Cyan
        
        # Import the layout
        Import-StartLayout -LayoutPath $layoutPath -MountPath $env:SystemDrive\
        
        # Alternative method for current user
        try {
            # Copy layout to system location
            $systemLayoutPath = "$env:LOCALAPPDATA\Microsoft\Windows\Shell\LayoutModification.xml"
            Copy-Item -Path $layoutPath -Destination $systemLayoutPath -Force
            
            # Restart Explorer to apply changes
            Write-Host "Restarting Windows Explorer to apply Start Menu layout..." -ForegroundColor Yellow
            Get-Process explorer | Stop-Process -Force
            Start-Sleep -Seconds 2
            Start-Process explorer
            
        } catch {
            Write-Host "Could not apply layout for current user: $($_.Exception.Message)" -ForegroundColor Yellow
        }
        
        # Clean up temporary file
        Remove-Item -Path $layoutPath -Force -ErrorAction SilentlyContinue
        
        Write-Host "Start Menu layout configuration completed" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to configure Start Menu layout: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You can manually organize your Start Menu using the groups suggested in the documentation" -ForegroundColor Yellow
    }
}

# Function to create custom Start Menu folders and shortcuts
function New-StartMenuShortcuts {
    try {
        Write-Host "Creating custom Start Menu shortcuts..." -ForegroundColor Cyan
        
        # Define Start Menu path
        $startMenuPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs"
        
        # Create custom folders for organization
        $folders = @(
            "System Administration",
            "Development Tools", 
            "Security & Network",
            "AI & Cloud Tools",
            "Productivity Tools"
        )
        
        foreach ($folder in $folders) {
            $folderPath = Join-Path $startMenuPath $folder
            if (!(Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force | Out-Null
                Write-Host "Created folder: $folder" -ForegroundColor Green
            }
        }
        
        # Create shortcuts for system tools that might not have them
        $shortcuts = @{
            "System Administration\Task Manager.lnk" = "C:\Windows\System32\Taskmgr.exe"
            "System Administration\System Information.lnk" = "C:\Windows\System32\msinfo32.exe"
            "System Administration\Event Viewer.lnk" = "C:\Windows\System32\eventvwr.exe"
            "System Administration\Device Manager.lnk" = "C:\Windows\System32\devmgmt.msc"
            "System Administration\Disk Management.lnk" = "C:\Windows\System32\diskmgmt.msc"
            "System Administration\Services.lnk" = "C:\Windows\System32\services.msc"
            "Security & Network\Windows Firewall.lnk" = "C:\Windows\System32\WF.msc"
            "Security & Network\Network Connections.lnk" = "C:\Windows\System32\ncpa.cpl"
        }
        
        # Create WScript Shell object for shortcuts
        $WshShell = New-Object -comObject WScript.Shell
        
        foreach ($shortcut in $shortcuts.GetEnumerator()) {
            $shortcutPath = Join-Path $startMenuPath $shortcut.Key
            if (!(Test-Path $shortcutPath) -and (Test-Path $shortcut.Value)) {
                $Shortcut = $WshShell.CreateShortcut($shortcutPath)
                $Shortcut.TargetPath = $shortcut.Value
                $Shortcut.Save()
                Write-Host "Created shortcut: $($shortcut.Key)" -ForegroundColor Green
            }
        }
        
        Write-Host "Custom Start Menu shortcuts created successfully" -ForegroundColor Green
        
    } catch {
        Write-Host "Failed to create custom shortcuts: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Function to pin essential apps to taskbar
function Set-TaskbarPins {
    try {
        Write-Host "Configuring taskbar pins..." -ForegroundColor Cyan
        
        # Essential apps to pin to taskbar
        $essentialApps = @(
            "Microsoft.WindowsTerminal_8wekyb3d8bbwe!App",
            "windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel",
            "Microsoft.Windows.Explorer"
        )
        
        # Note: Programmatic taskbar pinning is limited in Windows 10/11
        # This creates a registry entry for apps that should be pinned
        $taskbarRegPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Taskband"
        
        Write-Host "Essential apps for taskbar pinning:" -ForegroundColor Yellow
        Write-Host "- File Explorer" -ForegroundColor Gray
        Write-Host "- Windows Terminal" -ForegroundColor Gray  
        Write-Host "- Settings" -ForegroundColor Gray
        Write-Host "- Your primary browser" -ForegroundColor Gray
        Write-Host "- Visual Studio Code (if installed)" -ForegroundColor Gray
        Write-Host "`nPlease manually pin these apps by right-clicking and selecting 'Pin to taskbar'" -ForegroundColor Yellow
        
    } catch {
        Write-Host "Taskbar configuration note: $($_.Exception.Message)" -ForegroundColor Yellow
    }
}

# Apply Start Menu configuration based on mode
if ($Mode -eq "home") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (HOME MODE) ---" -ForegroundColor Cyan
    
    # Create custom shortcuts and folders
    New-StartMenuShortcuts
    
    # Apply the layout (this may require restart to take full effect)
    Set-StartMenuLayout
    
    # Taskbar configuration guidance
    Set-TaskbarPins
    
} elseif ($Mode -eq "work") {
    Write-Host "`n--- CONFIGURING START MENU LAYOUT (WORK MODE) ---" -ForegroundColor Cyan
    
    # Simplified layout for work environment
    New-StartMenuShortcuts
    
    # Work-specific taskbar recommendations
    Write-Host "Work environment taskbar recommendations:" -ForegroundColor Yellow
    Write-Host "- File Explorer, Settings, Windows Terminal" -ForegroundColor Gray
    Write-Host "- Office applications (Word, Excel, Outlook)" -ForegroundColor Gray
    Write-Host "- Your organization's primary applications" -ForegroundColor Gray
}

# ===================================================================
# SCRIPT COMPLETION
# ===================================================================

Write-Host "`n==================================================================" -ForegroundColor Cyan
Write-Host "Enhanced Windows configuration script completed successfully!" -ForegroundColor Green
Write-Host "Mode: $($Mode.ToUpper())" -ForegroundColor White
Write-Host "The following optimizations have been applied:" -ForegroundColor White
Write-Host "• Privacy and telemetry disabled" -ForegroundColor Gray
Write-Host "• Performance optimizations applied" -ForegroundColor Gray
Write-Host "• Security enhancements configured" -ForegroundColor Gray
Write-Host "• Network settings optimized" -ForegroundColor Gray
Write-Host "• Unnecessary services disabled" -ForegroundColor Gray
Write-Host "• Bloatware applications removed" -ForegroundColor Gray
Write-Host "• Disk cleanup performed" -ForegroundColor Gray
Write-Host "• Start Menu layout configured" -ForegroundColor Gray

if ($Mode -eq "home") {
    Write-Host "• Interactive software installation completed" -ForegroundColor Gray
    Write-Host "• Custom Start Menu groups created" -ForegroundColor Gray
} elseif ($Mode -eq "work") {
    Write-Host "• Work environment software installed" -ForegroundColor Gray
    Write-Host "• Business-focused Start Menu layout applied" -ForegroundColor Gray
}

Write-Host "`n📋 POST-INSTALLATION STEPS:" -ForegroundColor Yellow
Write-Host "1. Restart the computer to apply all changes" -ForegroundColor White
Write-Host "2. Check Start Menu layout and adjust as needed" -ForegroundColor White
Write-Host "3. Pin essential apps to taskbar manually" -ForegroundColor White
Write-Host "4. Sign in to your Microsoft account for sync" -ForegroundColor White
Write-Host "5. Configure Windows Update settings" -ForegroundColor White

if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "`n💾 BACKUP INFORMATION:" -ForegroundColor Yellow
    Write-Host "• Configuration backup completed before system changes" -ForegroundColor White
    if ($BackupSoftware) {
        Write-Host "• Standard backup: Use RESTORE_CONFIGURATIONS.ps1 to restore settings" -ForegroundColor White
    }
    if ($BackupAllInstalledSoftware) {
        Write-Host "• Comprehensive backup: Use RESTORE_ALL_CONFIGURATIONS.ps1 to restore all software" -ForegroundColor White
        Write-Host "• Detailed reports available in Reports folder" -ForegroundColor White
    }
    Write-Host "• Backup location saved in manifest files" -ForegroundColor White
}

Write-Host "`n🔧 MANUAL TASKS:" -ForegroundColor Yellow
Write-Host "• Taskbar pinning (right-click apps → 'Pin to taskbar')" -ForegroundColor White
Write-Host "• Windows Hello setup (if supported)" -ForegroundColor White
Write-Host "• Backup and sync configuration" -ForegroundColor White
Write-Host "• Browser extensions and bookmarks import" -ForegroundColor White

Write-Host "`n🔧 USAGE EXAMPLES:" -ForegroundColor Yellow
Write-Host "Basic usage: .\script.ps1 -Mode home" -ForegroundColor White
Write-Host "With standard backup: .\script.ps1 -Mode home -BackupSoftware" -ForegroundColor White
Write-Host "With comprehensive backup: .\script.ps1 -Mode home -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Both backups: .\script.ps1 -Mode work -BackupSoftware -BackupAllInstalledSoftware" -ForegroundColor White
Write-Host "Custom backup path: .\script.ps1 -Mode home -BackupSoftware -BackupBasePath 'D:\MyBackups'" -ForegroundColor White

Write-Host "`n📁 BACKUP STRUCTURE:" -ForegroundColor Yellow
if ($BackupSoftware -or $BackupAllInstalledSoftware) {
    Write-Host "Base Path: $BackupBasePath" -ForegroundColor White
    Write-Host "Session Path: $StandardBackupPath" -ForegroundColor White
    Write-Host "Structure: BackupBasePath\YYYY-MM-DD_HH-MM-SS\[BackupType]\[Applications]" -ForegroundColor Gray
}

Write-Host "`nPlease restart the computer to apply all changes." -ForegroundColor Yellow
Write-Host "==================================================================" -ForegroundColor Cyan